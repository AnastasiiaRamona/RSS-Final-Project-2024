/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@commercetools/platform-sdk/dist/commercetools-platform-sdk.browser.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@commercetools/platform-sdk/dist/commercetools-platform-sdk.browser.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApiRoot: () => (/* binding */ ApiRoot),
/* harmony export */   ByProjectKeyApiClientsByIDRequestBuilder: () => (/* binding */ ByProjectKeyApiClientsByIDRequestBuilder),
/* harmony export */   ByProjectKeyApiClientsRequestBuilder: () => (/* binding */ ByProjectKeyApiClientsRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdBusinessUnitsByIDRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdBusinessUnitsByIDRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdBusinessUnitsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdBusinessUnitsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdBusinessUnitsRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdBusinessUnitsRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsByIDRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsByIDRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesByIDRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesByIDRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsByIDRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsByIDRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsReplicateRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsReplicateRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersByIDRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersByIDRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersOrderNumberByOrderNumberRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersOrderNumberByOrderNumberRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersQuotesRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersQuotesRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsByIDRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsByIDRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesByIDRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesByIDRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateByAssociateIdRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateByAssociateIdRequestBuilder),
/* harmony export */   ByProjectKeyAsAssociateRequestBuilder: () => (/* binding */ ByProjectKeyAsAssociateRequestBuilder),
/* harmony export */   ByProjectKeyAssociateRolesByIDRequestBuilder: () => (/* binding */ ByProjectKeyAssociateRolesByIDRequestBuilder),
/* harmony export */   ByProjectKeyAssociateRolesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyAssociateRolesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyAssociateRolesRequestBuilder: () => (/* binding */ ByProjectKeyAssociateRolesRequestBuilder),
/* harmony export */   ByProjectKeyAttributeGroupsByIDRequestBuilder: () => (/* binding */ ByProjectKeyAttributeGroupsByIDRequestBuilder),
/* harmony export */   ByProjectKeyAttributeGroupsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyAttributeGroupsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyAttributeGroupsRequestBuilder: () => (/* binding */ ByProjectKeyAttributeGroupsRequestBuilder),
/* harmony export */   ByProjectKeyBusinessUnitsByIDRequestBuilder: () => (/* binding */ ByProjectKeyBusinessUnitsByIDRequestBuilder),
/* harmony export */   ByProjectKeyBusinessUnitsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyBusinessUnitsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyBusinessUnitsRequestBuilder: () => (/* binding */ ByProjectKeyBusinessUnitsRequestBuilder),
/* harmony export */   ByProjectKeyCartDiscountsByIDRequestBuilder: () => (/* binding */ ByProjectKeyCartDiscountsByIDRequestBuilder),
/* harmony export */   ByProjectKeyCartDiscountsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyCartDiscountsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyCartDiscountsRequestBuilder: () => (/* binding */ ByProjectKeyCartDiscountsRequestBuilder),
/* harmony export */   ByProjectKeyCartsByIDRequestBuilder: () => (/* binding */ ByProjectKeyCartsByIDRequestBuilder),
/* harmony export */   ByProjectKeyCartsCustomerIdByCustomerIdRequestBuilder: () => (/* binding */ ByProjectKeyCartsCustomerIdByCustomerIdRequestBuilder),
/* harmony export */   ByProjectKeyCartsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyCartsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyCartsReplicateRequestBuilder: () => (/* binding */ ByProjectKeyCartsReplicateRequestBuilder),
/* harmony export */   ByProjectKeyCartsRequestBuilder: () => (/* binding */ ByProjectKeyCartsRequestBuilder),
/* harmony export */   ByProjectKeyCategoriesByIDRequestBuilder: () => (/* binding */ ByProjectKeyCategoriesByIDRequestBuilder),
/* harmony export */   ByProjectKeyCategoriesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyCategoriesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyCategoriesRequestBuilder: () => (/* binding */ ByProjectKeyCategoriesRequestBuilder),
/* harmony export */   ByProjectKeyChannelsByIDRequestBuilder: () => (/* binding */ ByProjectKeyChannelsByIDRequestBuilder),
/* harmony export */   ByProjectKeyChannelsRequestBuilder: () => (/* binding */ ByProjectKeyChannelsRequestBuilder),
/* harmony export */   ByProjectKeyCustomObjectsByContainerByKeyRequestBuilder: () => (/* binding */ ByProjectKeyCustomObjectsByContainerByKeyRequestBuilder),
/* harmony export */   ByProjectKeyCustomObjectsByContainerRequestBuilder: () => (/* binding */ ByProjectKeyCustomObjectsByContainerRequestBuilder),
/* harmony export */   ByProjectKeyCustomObjectsRequestBuilder: () => (/* binding */ ByProjectKeyCustomObjectsRequestBuilder),
/* harmony export */   ByProjectKeyCustomerGroupsByIDRequestBuilder: () => (/* binding */ ByProjectKeyCustomerGroupsByIDRequestBuilder),
/* harmony export */   ByProjectKeyCustomerGroupsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyCustomerGroupsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyCustomerGroupsRequestBuilder: () => (/* binding */ ByProjectKeyCustomerGroupsRequestBuilder),
/* harmony export */   ByProjectKeyCustomersByIDRequestBuilder: () => (/* binding */ ByProjectKeyCustomersByIDRequestBuilder),
/* harmony export */   ByProjectKeyCustomersEmailConfirmRequestBuilder: () => (/* binding */ ByProjectKeyCustomersEmailConfirmRequestBuilder),
/* harmony export */   ByProjectKeyCustomersEmailTokenByEmailTokenRequestBuilder: () => (/* binding */ ByProjectKeyCustomersEmailTokenByEmailTokenRequestBuilder),
/* harmony export */   ByProjectKeyCustomersEmailTokenRequestBuilder: () => (/* binding */ ByProjectKeyCustomersEmailTokenRequestBuilder),
/* harmony export */   ByProjectKeyCustomersKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyCustomersKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyCustomersPasswordRequestBuilder: () => (/* binding */ ByProjectKeyCustomersPasswordRequestBuilder),
/* harmony export */   ByProjectKeyCustomersPasswordResetRequestBuilder: () => (/* binding */ ByProjectKeyCustomersPasswordResetRequestBuilder),
/* harmony export */   ByProjectKeyCustomersPasswordTokenByPasswordTokenRequestBuilder: () => (/* binding */ ByProjectKeyCustomersPasswordTokenByPasswordTokenRequestBuilder),
/* harmony export */   ByProjectKeyCustomersPasswordTokenRequestBuilder: () => (/* binding */ ByProjectKeyCustomersPasswordTokenRequestBuilder),
/* harmony export */   ByProjectKeyCustomersRequestBuilder: () => (/* binding */ ByProjectKeyCustomersRequestBuilder),
/* harmony export */   ByProjectKeyDiscountCodesByIDRequestBuilder: () => (/* binding */ ByProjectKeyDiscountCodesByIDRequestBuilder),
/* harmony export */   ByProjectKeyDiscountCodesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyDiscountCodesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyDiscountCodesRequestBuilder: () => (/* binding */ ByProjectKeyDiscountCodesRequestBuilder),
/* harmony export */   ByProjectKeyExtensionsByIDRequestBuilder: () => (/* binding */ ByProjectKeyExtensionsByIDRequestBuilder),
/* harmony export */   ByProjectKeyExtensionsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyExtensionsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyExtensionsRequestBuilder: () => (/* binding */ ByProjectKeyExtensionsRequestBuilder),
/* harmony export */   ByProjectKeyGraphqlRequestBuilder: () => (/* binding */ ByProjectKeyGraphqlRequestBuilder),
/* harmony export */   ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeCustomersRequestBuilder: () => (/* binding */ ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeCustomersRequestBuilder),
/* harmony export */   ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeRequestBuilder: () => (/* binding */ ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeRequestBuilder),
/* harmony export */   ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyRequestBuilder: () => (/* binding */ ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCartDiscountsByIDRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCartDiscountsByIDRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCartDiscountsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCartDiscountsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCartDiscountsRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCartDiscountsRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCartsByIDRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCartsByIDRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCartsCustomerIdByCustomerIdRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCartsCustomerIdByCustomerIdRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCartsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCartsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCartsReplicateRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCartsReplicateRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCartsRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCartsRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCustomersByIDRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCustomersByIDRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCustomersEmailConfirmRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCustomersEmailConfirmRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenByEmailTokenRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenByEmailTokenRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCustomersKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCustomersKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordResetRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordResetRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenByPasswordTokenRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenByPasswordTokenRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyCustomersRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyCustomersRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyLoginRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyLoginRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeActiveCartRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeActiveCartRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeCartsByIDRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeCartsByIDRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeCartsRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeCartsRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeEmailConfirmRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeEmailConfirmRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeLoginRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeLoginRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeOrdersByIDRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeOrdersByIDRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeOrdersRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeOrdersRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMePasswordRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMePasswordRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMePasswordResetRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMePasswordResetRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsByIDRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsByIDRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyMeSignupRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyMeSignupRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyOrdersByIDRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyOrdersByIDRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyOrdersOrderNumberByOrderNumberRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyOrdersOrderNumberByOrderNumberRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyOrdersRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyOrdersRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyProductProjectionsByIDRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyProductProjectionsByIDRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyProductProjectionsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyProductProjectionsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyProductProjectionsRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyProductProjectionsRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyProductSelectionAssignmentsRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyProductSelectionAssignmentsRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyProductTailoringRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyProductTailoringRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDProductTailoringRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDProductTailoringRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyProductTailoringRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyProductTailoringRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyProductsRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyProductsRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyShippingMethodsMatchingCartRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyShippingMethodsMatchingCartRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyShippingMethodsRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyShippingMethodsRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyShoppingListsByIDRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyShoppingListsByIDRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyShoppingListsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyShoppingListsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyInStoreKeyByStoreKeyShoppingListsRequestBuilder: () => (/* binding */ ByProjectKeyInStoreKeyByStoreKeyShoppingListsRequestBuilder),
/* harmony export */   ByProjectKeyInventoryByIDRequestBuilder: () => (/* binding */ ByProjectKeyInventoryByIDRequestBuilder),
/* harmony export */   ByProjectKeyInventoryKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyInventoryKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyInventoryRequestBuilder: () => (/* binding */ ByProjectKeyInventoryRequestBuilder),
/* harmony export */   ByProjectKeyLoginRequestBuilder: () => (/* binding */ ByProjectKeyLoginRequestBuilder),
/* harmony export */   ByProjectKeyMeActiveCartRequestBuilder: () => (/* binding */ ByProjectKeyMeActiveCartRequestBuilder),
/* harmony export */   ByProjectKeyMeBusinessUnitsByIDRequestBuilder: () => (/* binding */ ByProjectKeyMeBusinessUnitsByIDRequestBuilder),
/* harmony export */   ByProjectKeyMeBusinessUnitsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyMeBusinessUnitsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyMeBusinessUnitsRequestBuilder: () => (/* binding */ ByProjectKeyMeBusinessUnitsRequestBuilder),
/* harmony export */   ByProjectKeyMeCartsByIDRequestBuilder: () => (/* binding */ ByProjectKeyMeCartsByIDRequestBuilder),
/* harmony export */   ByProjectKeyMeCartsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyMeCartsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyMeCartsReplicateRequestBuilder: () => (/* binding */ ByProjectKeyMeCartsReplicateRequestBuilder),
/* harmony export */   ByProjectKeyMeCartsRequestBuilder: () => (/* binding */ ByProjectKeyMeCartsRequestBuilder),
/* harmony export */   ByProjectKeyMeEmailConfirmRequestBuilder: () => (/* binding */ ByProjectKeyMeEmailConfirmRequestBuilder),
/* harmony export */   ByProjectKeyMeLoginRequestBuilder: () => (/* binding */ ByProjectKeyMeLoginRequestBuilder),
/* harmony export */   ByProjectKeyMeOrdersByIDRequestBuilder: () => (/* binding */ ByProjectKeyMeOrdersByIDRequestBuilder),
/* harmony export */   ByProjectKeyMeOrdersQuotesRequestBuilder: () => (/* binding */ ByProjectKeyMeOrdersQuotesRequestBuilder),
/* harmony export */   ByProjectKeyMeOrdersRequestBuilder: () => (/* binding */ ByProjectKeyMeOrdersRequestBuilder),
/* harmony export */   ByProjectKeyMePasswordRequestBuilder: () => (/* binding */ ByProjectKeyMePasswordRequestBuilder),
/* harmony export */   ByProjectKeyMePasswordResetRequestBuilder: () => (/* binding */ ByProjectKeyMePasswordResetRequestBuilder),
/* harmony export */   ByProjectKeyMePaymentsByIDRequestBuilder: () => (/* binding */ ByProjectKeyMePaymentsByIDRequestBuilder),
/* harmony export */   ByProjectKeyMePaymentsRequestBuilder: () => (/* binding */ ByProjectKeyMePaymentsRequestBuilder),
/* harmony export */   ByProjectKeyMeQuoteRequestsByIDRequestBuilder: () => (/* binding */ ByProjectKeyMeQuoteRequestsByIDRequestBuilder),
/* harmony export */   ByProjectKeyMeQuoteRequestsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyMeQuoteRequestsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyMeQuoteRequestsRequestBuilder: () => (/* binding */ ByProjectKeyMeQuoteRequestsRequestBuilder),
/* harmony export */   ByProjectKeyMeQuotesByIDRequestBuilder: () => (/* binding */ ByProjectKeyMeQuotesByIDRequestBuilder),
/* harmony export */   ByProjectKeyMeQuotesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyMeQuotesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyMeQuotesRequestBuilder: () => (/* binding */ ByProjectKeyMeQuotesRequestBuilder),
/* harmony export */   ByProjectKeyMeRequestBuilder: () => (/* binding */ ByProjectKeyMeRequestBuilder),
/* harmony export */   ByProjectKeyMeShoppingListsByIDRequestBuilder: () => (/* binding */ ByProjectKeyMeShoppingListsByIDRequestBuilder),
/* harmony export */   ByProjectKeyMeShoppingListsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyMeShoppingListsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyMeShoppingListsRequestBuilder: () => (/* binding */ ByProjectKeyMeShoppingListsRequestBuilder),
/* harmony export */   ByProjectKeyMeSignupRequestBuilder: () => (/* binding */ ByProjectKeyMeSignupRequestBuilder),
/* harmony export */   ByProjectKeyMessagesByIDRequestBuilder: () => (/* binding */ ByProjectKeyMessagesByIDRequestBuilder),
/* harmony export */   ByProjectKeyMessagesRequestBuilder: () => (/* binding */ ByProjectKeyMessagesRequestBuilder),
/* harmony export */   ByProjectKeyOrdersByIDRequestBuilder: () => (/* binding */ ByProjectKeyOrdersByIDRequestBuilder),
/* harmony export */   ByProjectKeyOrdersEditsByIDApplyRequestBuilder: () => (/* binding */ ByProjectKeyOrdersEditsByIDApplyRequestBuilder),
/* harmony export */   ByProjectKeyOrdersEditsByIDRequestBuilder: () => (/* binding */ ByProjectKeyOrdersEditsByIDRequestBuilder),
/* harmony export */   ByProjectKeyOrdersEditsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyOrdersEditsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyOrdersEditsRequestBuilder: () => (/* binding */ ByProjectKeyOrdersEditsRequestBuilder),
/* harmony export */   ByProjectKeyOrdersImportRequestBuilder: () => (/* binding */ ByProjectKeyOrdersImportRequestBuilder),
/* harmony export */   ByProjectKeyOrdersOrderNumberByOrderNumberRequestBuilder: () => (/* binding */ ByProjectKeyOrdersOrderNumberByOrderNumberRequestBuilder),
/* harmony export */   ByProjectKeyOrdersQuotesRequestBuilder: () => (/* binding */ ByProjectKeyOrdersQuotesRequestBuilder),
/* harmony export */   ByProjectKeyOrdersRequestBuilder: () => (/* binding */ ByProjectKeyOrdersRequestBuilder),
/* harmony export */   ByProjectKeyOrdersSearchRequestBuilder: () => (/* binding */ ByProjectKeyOrdersSearchRequestBuilder),
/* harmony export */   ByProjectKeyPaymentsByIDRequestBuilder: () => (/* binding */ ByProjectKeyPaymentsByIDRequestBuilder),
/* harmony export */   ByProjectKeyPaymentsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyPaymentsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyPaymentsRequestBuilder: () => (/* binding */ ByProjectKeyPaymentsRequestBuilder),
/* harmony export */   ByProjectKeyProductDiscountsByIDRequestBuilder: () => (/* binding */ ByProjectKeyProductDiscountsByIDRequestBuilder),
/* harmony export */   ByProjectKeyProductDiscountsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyProductDiscountsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyProductDiscountsMatchingRequestBuilder: () => (/* binding */ ByProjectKeyProductDiscountsMatchingRequestBuilder),
/* harmony export */   ByProjectKeyProductDiscountsRequestBuilder: () => (/* binding */ ByProjectKeyProductDiscountsRequestBuilder),
/* harmony export */   ByProjectKeyProductProjectionsByIDRequestBuilder: () => (/* binding */ ByProjectKeyProductProjectionsByIDRequestBuilder),
/* harmony export */   ByProjectKeyProductProjectionsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyProductProjectionsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyProductProjectionsRequestBuilder: () => (/* binding */ ByProjectKeyProductProjectionsRequestBuilder),
/* harmony export */   ByProjectKeyProductProjectionsSearchRequestBuilder: () => (/* binding */ ByProjectKeyProductProjectionsSearchRequestBuilder),
/* harmony export */   ByProjectKeyProductProjectionsSuggestRequestBuilder: () => (/* binding */ ByProjectKeyProductProjectionsSuggestRequestBuilder),
/* harmony export */   ByProjectKeyProductSelectionsByIDProductsRequestBuilder: () => (/* binding */ ByProjectKeyProductSelectionsByIDProductsRequestBuilder),
/* harmony export */   ByProjectKeyProductSelectionsByIDRequestBuilder: () => (/* binding */ ByProjectKeyProductSelectionsByIDRequestBuilder),
/* harmony export */   ByProjectKeyProductSelectionsKeyByKeyProductsRequestBuilder: () => (/* binding */ ByProjectKeyProductSelectionsKeyByKeyProductsRequestBuilder),
/* harmony export */   ByProjectKeyProductSelectionsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyProductSelectionsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyProductSelectionsRequestBuilder: () => (/* binding */ ByProjectKeyProductSelectionsRequestBuilder),
/* harmony export */   ByProjectKeyProductTailoringByIDRequestBuilder: () => (/* binding */ ByProjectKeyProductTailoringByIDRequestBuilder),
/* harmony export */   ByProjectKeyProductTailoringKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyProductTailoringKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyProductTailoringRequestBuilder: () => (/* binding */ ByProjectKeyProductTailoringRequestBuilder),
/* harmony export */   ByProjectKeyProductTypesByIDRequestBuilder: () => (/* binding */ ByProjectKeyProductTypesByIDRequestBuilder),
/* harmony export */   ByProjectKeyProductTypesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyProductTypesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyProductTypesRequestBuilder: () => (/* binding */ ByProjectKeyProductTypesRequestBuilder),
/* harmony export */   ByProjectKeyProductsByIDImagesRequestBuilder: () => (/* binding */ ByProjectKeyProductsByIDImagesRequestBuilder),
/* harmony export */   ByProjectKeyProductsByIDProductSelectionsRequestBuilder: () => (/* binding */ ByProjectKeyProductsByIDProductSelectionsRequestBuilder),
/* harmony export */   ByProjectKeyProductsByIDRequestBuilder: () => (/* binding */ ByProjectKeyProductsByIDRequestBuilder),
/* harmony export */   ByProjectKeyProductsKeyByKeyProductSelectionsRequestBuilder: () => (/* binding */ ByProjectKeyProductsKeyByKeyProductSelectionsRequestBuilder),
/* harmony export */   ByProjectKeyProductsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyProductsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyProductsRequestBuilder: () => (/* binding */ ByProjectKeyProductsRequestBuilder),
/* harmony export */   ByProjectKeyProductsSearchRequestBuilder: () => (/* binding */ ByProjectKeyProductsSearchRequestBuilder),
/* harmony export */   ByProjectKeyQuoteRequestsByIDRequestBuilder: () => (/* binding */ ByProjectKeyQuoteRequestsByIDRequestBuilder),
/* harmony export */   ByProjectKeyQuoteRequestsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyQuoteRequestsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyQuoteRequestsRequestBuilder: () => (/* binding */ ByProjectKeyQuoteRequestsRequestBuilder),
/* harmony export */   ByProjectKeyQuotesByIDRequestBuilder: () => (/* binding */ ByProjectKeyQuotesByIDRequestBuilder),
/* harmony export */   ByProjectKeyQuotesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyQuotesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyQuotesRequestBuilder: () => (/* binding */ ByProjectKeyQuotesRequestBuilder),
/* harmony export */   ByProjectKeyRequestBuilder: () => (/* binding */ ByProjectKeyRequestBuilder),
/* harmony export */   ByProjectKeyReviewsByIDRequestBuilder: () => (/* binding */ ByProjectKeyReviewsByIDRequestBuilder),
/* harmony export */   ByProjectKeyReviewsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyReviewsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyReviewsRequestBuilder: () => (/* binding */ ByProjectKeyReviewsRequestBuilder),
/* harmony export */   ByProjectKeyShippingMethodsByIDRequestBuilder: () => (/* binding */ ByProjectKeyShippingMethodsByIDRequestBuilder),
/* harmony export */   ByProjectKeyShippingMethodsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyShippingMethodsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyShippingMethodsMatchingCartLocationRequestBuilder: () => (/* binding */ ByProjectKeyShippingMethodsMatchingCartLocationRequestBuilder),
/* harmony export */   ByProjectKeyShippingMethodsMatchingCartRequestBuilder: () => (/* binding */ ByProjectKeyShippingMethodsMatchingCartRequestBuilder),
/* harmony export */   ByProjectKeyShippingMethodsMatchingLocationRequestBuilder: () => (/* binding */ ByProjectKeyShippingMethodsMatchingLocationRequestBuilder),
/* harmony export */   ByProjectKeyShippingMethodsMatchingOrdereditRequestBuilder: () => (/* binding */ ByProjectKeyShippingMethodsMatchingOrdereditRequestBuilder),
/* harmony export */   ByProjectKeyShippingMethodsRequestBuilder: () => (/* binding */ ByProjectKeyShippingMethodsRequestBuilder),
/* harmony export */   ByProjectKeyShoppingListsByIDRequestBuilder: () => (/* binding */ ByProjectKeyShoppingListsByIDRequestBuilder),
/* harmony export */   ByProjectKeyShoppingListsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyShoppingListsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyShoppingListsRequestBuilder: () => (/* binding */ ByProjectKeyShoppingListsRequestBuilder),
/* harmony export */   ByProjectKeyStagedQuotesByIDRequestBuilder: () => (/* binding */ ByProjectKeyStagedQuotesByIDRequestBuilder),
/* harmony export */   ByProjectKeyStagedQuotesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyStagedQuotesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyStagedQuotesRequestBuilder: () => (/* binding */ ByProjectKeyStagedQuotesRequestBuilder),
/* harmony export */   ByProjectKeyStandalonePricesByIDRequestBuilder: () => (/* binding */ ByProjectKeyStandalonePricesByIDRequestBuilder),
/* harmony export */   ByProjectKeyStandalonePricesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyStandalonePricesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyStandalonePricesRequestBuilder: () => (/* binding */ ByProjectKeyStandalonePricesRequestBuilder),
/* harmony export */   ByProjectKeyStatesByIDRequestBuilder: () => (/* binding */ ByProjectKeyStatesByIDRequestBuilder),
/* harmony export */   ByProjectKeyStatesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyStatesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyStatesRequestBuilder: () => (/* binding */ ByProjectKeyStatesRequestBuilder),
/* harmony export */   ByProjectKeyStoresByIDRequestBuilder: () => (/* binding */ ByProjectKeyStoresByIDRequestBuilder),
/* harmony export */   ByProjectKeyStoresKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyStoresKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyStoresRequestBuilder: () => (/* binding */ ByProjectKeyStoresRequestBuilder),
/* harmony export */   ByProjectKeySubscriptionsByIDHealthRequestBuilder: () => (/* binding */ ByProjectKeySubscriptionsByIDHealthRequestBuilder),
/* harmony export */   ByProjectKeySubscriptionsByIDRequestBuilder: () => (/* binding */ ByProjectKeySubscriptionsByIDRequestBuilder),
/* harmony export */   ByProjectKeySubscriptionsKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeySubscriptionsKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeySubscriptionsRequestBuilder: () => (/* binding */ ByProjectKeySubscriptionsRequestBuilder),
/* harmony export */   ByProjectKeyTaxCategoriesByIDRequestBuilder: () => (/* binding */ ByProjectKeyTaxCategoriesByIDRequestBuilder),
/* harmony export */   ByProjectKeyTaxCategoriesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyTaxCategoriesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyTaxCategoriesRequestBuilder: () => (/* binding */ ByProjectKeyTaxCategoriesRequestBuilder),
/* harmony export */   ByProjectKeyTypesByIDRequestBuilder: () => (/* binding */ ByProjectKeyTypesByIDRequestBuilder),
/* harmony export */   ByProjectKeyTypesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyTypesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyTypesRequestBuilder: () => (/* binding */ ByProjectKeyTypesRequestBuilder),
/* harmony export */   ByProjectKeyZonesByIDRequestBuilder: () => (/* binding */ ByProjectKeyZonesByIDRequestBuilder),
/* harmony export */   ByProjectKeyZonesKeyByKeyRequestBuilder: () => (/* binding */ ByProjectKeyZonesKeyByKeyRequestBuilder),
/* harmony export */   ByProjectKeyZonesRequestBuilder: () => (/* binding */ ByProjectKeyZonesRequestBuilder),
/* harmony export */   createApiBuilderFromCtpClient: () => (/* binding */ createApiBuilderFromCtpClient),
/* harmony export */   createExecutorFromMiddlewares: () => (/* binding */ createExecutorFromMiddlewares)
/* harmony export */ });
function toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate <raml_file_path> -o <output_path> -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */

function isDefined(value) {
  return typeof value !== 'undefined' && value !== null;
}
function stringify(object) {
  const params = new URLSearchParams(object);
  for (const [key, value] of Object.entries(object)) {
    if (Array.isArray(value)) {
      params.delete(key);
      value.filter(Boolean).forEach(v => params.append(key, v));
    }
  }
  return params.toString();
}
function cleanObject(obj) {
  return Object.keys(obj).reduce((result, key) => {
    const value = obj[key];
    if (Array.isArray(value)) {
      const values = value.filter(isDefined);
      if (!values.length) {
        return result;
      }
      return {
        ...result,
        [key]: values
      };
    }
    if (isDefined(value)) {
      return {
        ...result,
        [key]: value
      };
    }
    return result;
  }, {});
}
function formatQueryString(variableMap) {
  const map = cleanObject(variableMap);
  const result = stringify(map);
  if (result === '') {
    return '';
  }
  return `?${result}`;
}
function buildRelativeUri(commonRequest) {
  const pathMap = commonRequest.pathVariables;
  var uri = commonRequest.uriTemplate;
  for (const param in pathMap) {
    const value = encodeURIComponent(`${pathMap[param]}`);
    uri = uri.replace(`{${param}}`, `${value}`);
  }
  const resQuery = formatQueryString(commonRequest.queryParams || {});
  return `${uri}${resQuery}`;
}

class ApiRequest {
  constructor(request, requestExecutor) {
    this.requestExecutor = requestExecutor;
    _defineProperty(this, "request", void 0);
    this.request = {
      ...request,
      uri: buildRelativeUri(request)
    };
  }
  clientRequest() {
    return this.request;
  }
  execute() {
    return this.requestExecutor(this.request);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeActiveCartRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the Customer's most recently modified active Cart in the Store specified by the `storeKey` path parameter.
   *
   *	Carts with `Merchant` or `Quote` [CartOrigin](ctp:api:type:CartOrigin) are ignored.
   *
   *	If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/active-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an active Cart exists. Returns a `200 OK` status if an active Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/active-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeActiveCartRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the Customer's most recently modified active Cart.
   *	Carts with `Merchant` or `Quote` [CartOrigin](ctp:api:type:CartOrigin) are ignored.
   *
   *	If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/active-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an active Cart exists. Returns a `200 OK` status if an active Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/active-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyApiClientsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/api-clients/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an API Client exists for a given `id`. Returns a `200 OK` status if the API Client exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/api-clients/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/api-clients/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyApiClientsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyApiClientsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/api-clients',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an API Client exists for a given Query Predicate. Returns a `200 OK` status if any API Clients match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/api-clients',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/api-clients',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdBusinessUnitsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `id`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdBusinessUnitsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `key`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdBusinessUnitsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdBusinessUnitsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdBusinessUnitsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given Query Predicate. Returns a `200 OK` status if any BusinessUnits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-flows/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-flows/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-flows',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/approval-rules',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsReplicateRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creates a new Cart by replicating an existing Cart or Order. Can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order. If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart. If the Customer switches to another Customer Group, the new Cart is updated with the new value. It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain Payments or Deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/replicate',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  replicate() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creates a [Cart](ctp:api:type:Cart) in the [BusinessUnit](ctp:api:type:BusinessUnit) referenced by `businessUnitKey`. As such, the `businessUnit` field on [CartDraft](ctp:api:type:CartDraft) is ignored for this request.
   *	Creating a Cart can fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the referenced [ShippingMethod](ctp:api:type:ShippingMethod) in the [CartDraft](ctp:api:type:CartDraft) has a predicate that does not match the Cart.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creates an Order from a [Quote](ctp:api:type:Cart) in a [BusinessUnit](ctp:api:type:BusinessUnit).
   *	Creating an Order fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the Quote does not reference the same BusinessUnit as the `businessUnitKey` path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersOrderNumberByOrderNumberRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `orderNumber`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  orderQuote() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withOrderNumber(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersOrderNumberByOrderNumberRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creates an Order from a [Cart](ctp:api:type:Cart) in a [BusinessUnit](ctp:api:type:BusinessUnit).
   *	The Cart must have a shipping address set before creating an Order.
   *	Creating an Order fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the Cart does not reference the same BusinessUnit as the `businessUnitKey` path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given `id`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given `key`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the QuoteRequest exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given Query Predicate. Returns a `200 OK` status if any QuoteRequests match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creates a QuoteRequest in a [BusinessUnit](ctp:api:type:BusinessUnit). Creating QuoteRequest fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) if the Cart does not reference the same BusinessUnit as the `businessUnitKey` path parameter.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `id`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `key`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Quote exists in the [Project](ctp:api:type:Project) but does not reference the requested [BusinessUnit](ctp:api:type:BusinessUnit), this method returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given Query Predicate. Returns a `200 OK` status if any Quotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/as-associate/{associateId}/in-business-unit/key={businessUnitKey}/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	An Approval Rule describes the conditions determining whether an Order that matches the predicate needs approval by an approver before it can be ordered by an requester within a Business Unit.
   */
  approvalRules() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalRulesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Approval Flows connect Orders that require approval with the Approval Rules that initiate the approval requirement.
   *	They represent the approval process by including information about approvals, rejections, and all involved parties.
   *
   */
  approvalFlows() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyApprovalFlowsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  orders() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A quote holds the negotiated offer.
   */
  quotes() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  quoteRequests() {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyQuoteRequestsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateByAssociateIdRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	A Business Unit can represent a Company or a Division.
   */
  businessUnits() {
    return new ByProjectKeyAsAssociateByAssociateIdBusinessUnitsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  inBusinessUnitKeyWithBusinessUnitKeyValue(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdInBusinessUnitKeyByBusinessUnitKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAsAssociateRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withAssociateIdValue(childPathArgs) {
    return new ByProjectKeyAsAssociateByAssociateIdRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAssociateRolesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/associate-roles/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AssociateRole exists for a given `id`. Returns a `200 OK` status if the AssociateRole exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/associate-roles/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/associate-roles/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/associate-roles/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAssociateRolesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/associate-roles/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AssociateRole exists for a given `key`. Returns a `200 OK` status if the AssociateRole exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/associate-roles/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/associate-roles/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting an AssociateRole generates the [AssociateRoleDeleted](ctp:api:type:AssociateRoleDeletedMessage) Message. An AssociateRole can only be deleted if it is not assigned to any [Associates](ctp:api:type:Associate).
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/associate-roles/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAssociateRolesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAssociateRolesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAssociateRolesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/associate-roles',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AssociateRole exists for a given Query Predicate. Returns a `200 OK` status if any AssociateRole match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/associate-roles',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Associate Role generates the [AssociateRoleCreated](ctp:api:type:AssociateRoleCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/associate-roles',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAttributeGroupsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/attribute-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AttributeGroup exists for a given `id`. Returns a `200 OK` status if the AttributeGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/attribute-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/attribute-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/attribute-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAttributeGroupsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/attribute-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AttributeGroup exists for a given `key`. Returns `200 OK` status if the AttributeGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/attribute-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/attribute-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/attribute-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyAttributeGroupsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyAttributeGroupsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyAttributeGroupsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/attribute-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an AttributeGroup exists for a given Query Predicate. Returns `200 OK` status if any AttributeGroups match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/attribute-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/attribute-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyBusinessUnitsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `id`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyBusinessUnitsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `key`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyBusinessUnitsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyBusinessUnitsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyBusinessUnitsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given Query Predicate. Returns a `200 OK` status if any BusinessUnits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCartDiscountsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given `id`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCartDiscountsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given `key`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCartDiscountsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyCartDiscountsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyCartDiscountsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given Query Predicate. Returns a `200 OK` status if any CartDiscounts match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Cart Discount produces the [CartDiscountCreated](ctp:api:type:CartDiscountCreatedMessage) Message.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCartsReplicateRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creates a new Cart by replicating an existing Cart or Order. Can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order. If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart. If the Customer switches to another Customer Group, the new Cart is updated with the new value. It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain Payments or Deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/carts/replicate',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCartsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCartsCustomerIdByCustomerIdRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the recently modified active Cart of a Customer with [CartOrigin](ctp:api:type:CartOrigin) `Customer`. If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/carts/customer-id={customerId}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart of a Customer exists. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/carts/customer-id={customerId}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCartsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCartsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  replicate() {
    return new ByProjectKeyCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withCustomerId(childPathArgs) {
    return new ByProjectKeyCartsCustomerIdByCustomerIdRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Cart fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) error if the
   *	[ShippingMethod](ctp:api:type:ShippingMethod) referenced in the CartDraft
   *	has a `predicate` that does not match the Cart.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCategoriesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Either the [scope](/../api/scopes) `view_products:{projectKey}` or `view_categories:{projectKey}` is required.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Category exists for a given `id`. Returns a `200 OK` status if the Category exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCategoriesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Either the [scope](/../api/scopes) `view_products:{projectKey}` or `view_categories:{projectKey}` is required.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Category exists for a given `key`. Returns a `200 OK` status if the Category exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCategoriesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyCategoriesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyCategoriesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	Either the [scope](/../api/scopes) `view_products:{projectKey}` or `view_categories:{projectKey}` is required.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/categories',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Category exists for on a given Query Predicate. Returns a `200 OK` status if any Categories match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/categories',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Either the [scope](/../api/scopes) `manage_products:{projectKey}` or `manage_categories:{projectKey}` is required.
   *
   *	Creating a Category produces the [CategoryCreated](ctp:api:type:CategoryCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/categories',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyChannelsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/channels/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Channel exists for a given `id`. Returns a `200 OK` status if the Channel exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/channels/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/channels/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Returns a [ReferenceExists](ctp:api:type:ReferenceExistsError) error if other resources reference the Channel to be deleted.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/channels/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyChannelsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyChannelsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/channels',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Channel exists for a given Query Predicate. Returns a `200 OK` status if any Channels match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/channels',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/channels',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomObjectsByContainerByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/custom-objects/{container}/{key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/custom-objects/{container}/{key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomObjectsByContainerRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/custom-objects/{container}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomObjectsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withContainerAndKey(childPathArgs) {
    return new ByProjectKeyCustomObjectsByContainerByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withContainer(childPathArgs) {
    return new ByProjectKeyCustomObjectsByContainerRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	For performance reasons, it is highly advisable to query for Custom Objects in a container by using the `container` field in the `where` predicate.
   *
   */
  /**
   * @deprecated
   **/
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/custom-objects',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CustomObject exists for a given Query Predicate. Returns a `200 OK` status if any CustomObjects match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/custom-objects',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	If an object with the given container/key exists, the object will be replaced with the new value and the version is incremented.
   *	If the request contains a version and an object with the given container/key, then the version must match the version of the existing object. Concurrent updates to the same Custom Object returns a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error even if the version is not provided.
   *
   *	Fields with `null` values will **not be saved**.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/custom-objects',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomerGroupsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customer-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CustomerGroup exists for a given `id`. Returns a `200 OK` status if the CustomerGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customer-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customer-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/customer-groups/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomerGroupsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customer-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CustomerGroup exists for a given `key`. Returns a `200 OK` status if the CustomerGroup exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customer-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customer-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/customer-groups/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomerGroupsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyCustomerGroupsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyCustomerGroupsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customer-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CustomerGroup exists for a given Query Predicate. Returns a `200 OK` status if any CustomerGroup match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customer-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customer-groups',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomersEmailConfirmRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Verifying the email of the Customer produces the [CustomerEmailVerified](ctp:api:type:CustomerEmailVerifiedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/email/confirm',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomersEmailTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Produces the [CustomerEmailTokenCreated](ctp:api:type:CustomerEmailTokenCreatedMessage) Message.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/email-token',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomersPasswordTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/password-token',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomersPasswordRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Changing the password produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/password',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomersPasswordResetRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Resetting the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/password/reset',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given `id`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Simultaneously updating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomersEmailTokenByEmailTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customers/email-token={emailToken}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomersKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given `key`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Simultaneously updating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomersPasswordTokenByPasswordTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customers/password-token={passwordToken}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyCustomersRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withPasswordToken(childPathArgs) {
    return new ByProjectKeyCustomersPasswordTokenByPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withEmailToken(childPathArgs) {
    return new ByProjectKeyCustomersEmailTokenByEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  emailToken() {
    return new ByProjectKeyCustomersEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  emailConfirm() {
    return new ByProjectKeyCustomersEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  password() {
    return new ByProjectKeyCustomersPasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  passwordReset() {
    return new ByProjectKeyCustomersPasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Produces the [CustomerPasswordTokenCreated](ctp:api:type:CustomerPasswordTokenCreatedMessage) Message.
   */
  passwordToken() {
    return new ByProjectKeyCustomersPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyCustomersKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyCustomersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given Query Predicate. Returns a `200 OK` status if any Customers match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	If the `anonymousCart` field is set on the [CustomerDraft](ctp:api:type:CustomerDraft), then the newly created Customer will be assigned to that [Cart](ctp:api:type:Cart).
   *	Similarly, if the `anonymousId` field is set, the Customer will be set on all [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [ShoppingLists](ctp:api:type:ShoppingList) and [Payments](ctp:api:type:Payment) with the same `anonymousId`.
   *
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message. Simultaneously creating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyDiscountCodesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/discount-codes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a DiscountCode exists for a given `id`. Returns a `200 OK` status if the DiscountCode exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/discount-codes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Deprecated scope: `manage_orders:{projectKey}`
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/discount-codes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Discount Code produces the [DiscountCodeDeleted](ctp:api:type:DiscountCodeDeletedMessage) Message.
   *
   *	Deprecated scope: `manage_orders:{projectKey}`
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/discount-codes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyDiscountCodesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/discount-codes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a DiscountCode exists for a given `key`. Returns a `200 OK` status if the DiscountCode exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/discount-codes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Deprecated scope: `manage_orders:{projectKey}`
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/discount-codes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Discount Code produces the [DiscountCodeDeleted](ctp:api:type:DiscountCodeDeletedMessage) Message.
   *
   *	Deprecated scope: `manage_orders:{projectKey}`
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/discount-codes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyDiscountCodesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyDiscountCodesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyDiscountCodesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/discount-codes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a DiscountCode exists for a given Query Predicate. Returns a `200 OK` status if any DiscountCodes match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/discount-codes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Discount Code produces the [DiscountCodeCreated](ctp:api:type:DiscountCodeCreatedMessage) Message.
   *
   *	Deprecated scope: `manage_orders:{projectKey}`
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/discount-codes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyExtensionsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/extensions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Extension exists for a given `id`. Returns a `200 OK` status if the Extension exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/extensions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/extensions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/extensions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyExtensionsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/extensions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Extension exists for a given `key`. Returns a `200 OK` status if the Extension exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/extensions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/extensions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/extensions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyExtensionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyExtensionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyExtensionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/extensions',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Extension exists for a given Query Predicate. Returns a `200 OK` status if any Extensions match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/extensions',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/extensions',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyGraphqlRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Execute a GraphQL query
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/graphql',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/graphql',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeCustomersRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	The My Business Unit endpoint does not support assigning existing Customers to a Business Unit.
   *	Associates with the `UpdateAssociates` [Permission](ctp:api:type:Permission) can use this endpoint to create a new Customer and associate it with the Business Unit.
   *	If the required [Permission](/projects/associate-roles#permission) is missing, an [AssociateMissingPermission](/errors#associatemissingpermission) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-business-unit/key={businessUnitKey}/me/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  customers() {
    return new ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeCustomersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  me() {
    return new ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyMeRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCartDiscountsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given `id`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	To update a CartDiscount, you must have permissions for all Stores the CartDiscount is associated with, except when [removing a Store](ctp:api:type:CartDiscountRemoveStoreAction).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	To delete a CartDiscount, specify the `manage_cart_discounts:{projectKey}:{storeKey}` scope for all Stores associated with the CartDiscount.
   *
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCartDiscountsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given `key`. Returns a `200 OK` status if the CartDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	To update a CartDiscount, you must have permissions for all Stores the CartDiscount is associated with, except when [removing a Store](ctp:api:type:CartDiscountRemoveStoreAction).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	To delete a CartDiscount, specify the `manage_cart_discounts:{projectKey}:{storeKey}` scope for all Stores associated with the CartDiscount.
   *
   *	Deleting a Cart Discount produces the [CartDiscountDeleted](ctp:api:type:CartDiscountDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCartDiscountsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartDiscountsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartDiscountsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a CartDiscount exists for a given Query Predicate. Returns a `200 OK` status if any CartDiscounts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	When using the endpoint, the Store specified in the path and the Stores specified in the payload's `stores` field are added to the CartDiscount.
   *
   *	Creating a Cart Discount produces the [CartDiscountCreated](ctp:api:type:CartDiscountCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/cart-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCartsReplicateRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creates a new Cart by replicating an existing Cart or Order. Can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order. If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart. If the Customer switches to another Customer Group, the new Cart is updated with the new value. It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain payments or deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/replicate',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCartsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Updates a [Cart](ctp:api:type:Cart) in the [Store](ctp:api:type:Store) specified by `storeKey`.
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCartsCustomerIdByCustomerIdRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the recently modified active Cart of a Customer with [CartOrigin](ctp:api:type:CartOrigin) `Customer`. If no active Cart exists, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/customer-id={customerId}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart of a Customer exists. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/customer-id={customerId}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCartsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	To ensure the Cart is up-to-date with current values (such as Prices and Discounts), use the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCartsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withCustomerId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsCustomerIdByCustomerIdRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  replicate() {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	Queries carts in a specific [Store](ctp:api:type:Store).
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creates a [Cart](ctp:api:type:Cart) in the [Store](ctp:api:type:Store) specified by `storeKey`.
   *	When using this endpoint the Cart's `store` field is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *	If the referenced [ShippingMethod](ctp:api:type:ShippingMethod) in the [CartDraft](ctp:api:type:CartDraft) has a predicate that does not match, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCustomersEmailConfirmRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	The customer verifies the email using the token value.
   *	Verifying the email of the Customer produces the [CustomerEmailVerified](ctp:api:type:CustomerEmailVerifiedMessage) Message.
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/email/confirm',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/email-token',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/password-token',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Changing the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/password',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordResetRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Resetting the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/password/reset',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCustomersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given `id`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	Simultaneously updating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenByEmailTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/email-token={emailToken}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCustomersKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given `key`. Returns a `200 OK` status if the Customer exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	Simultaneously updating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting a Customer produces the [CustomerDeleted](ctp:api:type:CustomerDeletedMessage) Message.
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenByPasswordTokenRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Customer exists in the Project but the `stores` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers/password-token={passwordToken}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyCustomersRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withPasswordToken(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenByPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withEmailToken(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenByEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  emailToken() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersEmailTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  emailConfirm() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  password() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  passwordReset() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  passwordToken() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersPasswordTokenRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Customer exists for a given Query Predicate. Returns a `200 OK` status if any Customers match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	When using this endpoint, if omitted, the Customer `stores` field is set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   *	If the `anonymousCart` field is set on the [CustomerDraft](ctp:api:type:CustomerDraft), then the newly created Customer will be assigned to that [Cart](ctp:api:type:Cart).
   *	Similarly, if the `anonymousId` field is set, the Customer will be set on all [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [ShoppingLists](ctp:api:type:ShoppingList) and [Payments](ctp:api:type:Payment) with the same `anonymousId`.
   *	If a Cart with a `store` field specified, the `store` field must reference the same [Store](ctp:api:type:Store) specified in the `{storeKey}` path parameter.
   *
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message. Simultaneously creating two Customers with the same email address can return a [LockedField](ctp:api:type:LockedFieldError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/customers',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyLoginRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Authenticates a Customer associated with a [Store](ctp:api:type:Store). For more information, see [Global versus Store-specific Customers](/../api/customers-overview#global-versus-store-specific-customers).
   *
   *	Triggers [Cart merge during sign-in](/../api/customers-overview#cart-merge-during-sign-in).
   *
   *	If the Customer exists in the Project but the `stores` field references a different [Store](ctp:api:type:Store), this method returns an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/login',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeCartsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks ifa My Cart exists for a given `id`. Returns a `200 OK` status if the My Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Cart exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeCartsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	The `store` field in the created [Cart](ctp:api:type:Cart) is set to the Store specified by the `storeKey` path parameter.
   *
   *	Specific Error Codes: [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeEmailConfirmRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This is the last step in the [email verification process of a Customer](/../api/projects/customers#email-verification-of-customer-in-store).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/email/confirm',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeLoginRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the authenticated Customer (that matches the given email/password pair) if they are part of a specific [Store](ctp:api:type:Store).
   *
   *	- If the Customer does not have a Cart, the most recently modified anonymous cart becomes the Customer's Cart.
   *	- If the Customer already has a Cart, the most recently modified anonymous cart is handled according to [AnonymousCartSignInMode](ctp:api:type:AnonymousCartSignInMode).
   *
   *	If a Cart is returned as part of [CustomerSignInResult](ctp:api:type:CustomerSignInResult), it has been [recalculated](ctp:api:type:MyCartRecalculateAction) with up-to-date prices, taxes, discounts, and invalid line items removed.
   *
   *	If an account with the given credentials is not found, an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/login',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeOrdersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the My Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeOrdersRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	The Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction) for taxes to be calculated. When creating [B2B Orders](/associates-overview#b2b-resources), the Customer must have the `CreateMyOrdersFromMyCarts` [Permission](ctp:api:type:Permission).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *	- [AssociateMissingPermission](ctp:api:type:AssociateMissingPermissionError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMePasswordResetRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This is the last step in the [password reset process of the authenticated Customer](/../api/projects/customers#password-reset-of-customer-in-store).
   *
   *	Resetting a password produces the of the Customer [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/password/reset',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMePasswordRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  reset() {
    return new ByProjectKeyInStoreKeyByStoreKeyMePasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	Changing the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/password',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store), the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	When using this endpoint, the `store` field of a ShoppingList is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeSignupRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If omitted in the request body, the [Customer](ctp:api:type:Customer) `stores` field is set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me/signup',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyMeRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	An order can be created from a order, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  activeCart() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeActiveCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	shopping-lists e.g. for wishlist support
   *
   */
  shoppingLists() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  emailConfirm() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  password() {
    return new ByProjectKeyInStoreKeyByStoreKeyMePasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  signup() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeSignupRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  login() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyOrdersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyOrdersOrderNumberByOrderNumberRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `orderNumber`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If the Order exists in the Project but does not have the `store` field, or the `store` field references a different Store, this method returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error.
   *
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyOrdersRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withOrderNumber(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyOrdersOrderNumberByOrderNumberRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Before you create an Order, the Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction).
   *	The shipping address is used for tax calculation for a Cart with `Platform` [TaxMode](ctp:api:type:TaxMode).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [ShippingMethodDoesNotMatchCart](ctp:api:type:ShippingMethodDoesNotMatchCartError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError)
   *	- [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyProductProjectionsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) by its ID in the specified [Store](ctp:api:type:Store).
   *	If the Store has defined some languages, countries, distribution, supply Channels, and/or Product Selection,
   *	they are used for projections based on [locale](ctp:api:type:ProductProjectionLocales), [price](ctp:api:type:ProductProjectionPrices),
   *	and [inventory](ctp:api:type:ProductProjectionInventoryEntries).
   *
   *	If [ProductSelection](ctp:api:type:ProductSelection) is used, it affects the [availability of the Product](/projects/stores#products-available-in-store) in the specified Store.
   *
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope, this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-projections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if the current or staged representations of a Product exists for a given `id` in the specified [Store](ctp:api:type:Store). Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-projections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyProductProjectionsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) by its key in the specified [Store](ctp:api:type:Store).
   *	If the Store has defined some languages, countries, distribution, supply Channels, and/or Product Selection,
   *	they are used for projections based on [locale](ctp:api:type:ProductProjectionLocales), [price](ctp:api:type:ProductProjectionPrices),
   *	and [inventory](ctp:api:type:ProductProjectionInventoryEntries).
   *
   *	If [ProductSelection](ctp:api:type:ProductSelection) is used, it affects the [availability of the Product](/projects/stores#products-available-in-store) in the specified Store.
   *
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope, this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-projections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if the current or staged representations of a Product exists for a given `key` in the specified [Store](ctp:api:type:Store). Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-projections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyProductProjectionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyProductProjectionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyProductProjectionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyProductSelectionAssignmentsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Queries Product Selection assignments in a specific [Store](ctp:api:type:Store).
   *
   *	The response will include duplicate Products whenever more than one active Product Selection of the Store
   *	includes a Product. To make clear through which Product Selection a Product is available in the Store
   *	the response contains assignments including both the Product and the Product Selection.
   *	Only Products of Product Selections that are activated in the Store will be returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-selection-assignments',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyProductTailoringRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Queries Product Tailoring in a specific [Store](ctp:api:type:Store).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creates a [ProductTailoring](ctp:api:type:ProductTailoring) in the [Store](ctp:api:type:Store) specified by `storeKey`.
   *	When using this endpoint the ProductTailoring's `store` field is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   *	Generates the [ProductTailoringCreated](ctp:api:type:ProductTailoringCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDProductTailoringRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Gets the current or staged representation of a [Product Tailoring](ctp:api:type:ProductTailoring) by its Product ID in the specified [Store](ctp:api:type:Store).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/{productID}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Updates the current or staged representation of a [Product Tailoring](ctp:api:type:ProductTailoring) by its Product ID in the specified [Store](ctp:api:type:Store).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/{productID}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Generates the [ProductTailoringDeleted](ctp:api:type:ProductTailoringDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/{productID}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  productTailoring() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDProductTailoringRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyProductTailoringRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Gets the current or staged representation of a [Product Tailoring](ctp:api:type:ProductTailoring) by its Product key in the specified [Store](ctp:api:type:Store).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/key={productKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Updates the current or staged representation of a [Product Tailoring](ctp:api:type:ProductTailoring) by its Product key in the specified [Store](ctp:api:type:Store).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/key={productKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Generates the [ProductTailoringDeleted](ctp:api:type:ProductTailoringDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/products/key={productKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  productTailoring() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyProductTailoringRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyProductsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withProductId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyProductsByProductIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withProductKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyProductsKeyByProductKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyShippingMethodsMatchingCartRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves all the ShippingMethods that can ship to the shipping address of the given Cart in a given [Store](ctp:api:type:Store).
   *	Each ShippingMethod contains exactly one ShippingRate with the flag `isMatching` set to `true`.
   *	This ShippingRate is used when the ShippingMethod is [added to the Cart](ctp:api:type:CartSetShippingMethodAction).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shipping-methods/matching-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod that can ship to the shipping address of the given Cart exists in the given [Store](ctp:api:type:Store). Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shipping-methods/matching-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyShippingMethodsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Get ShippingMethods for a cart in a store
   */
  matchingCart() {
    return new ByProjectKeyInStoreKeyByStoreKeyShippingMethodsMatchingCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyShoppingListsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyShoppingListsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If a ShoppingList exists in a Project but does _not_ have the `store` field, or the `store` field references a different [Store](ctp:api:type:Store),
   *	the [ResourceNotFound](/errors#404-not-found-1) error is returned.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyShoppingListsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	When using this endpoint, the `store` field of a ShoppingList is always set to the [Store](ctp:api:type:Store) specified in the path parameter.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/in-store/key={storeKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInStoreKeyByStoreKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyInStoreKeyByStoreKeyCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	An order can be created from a cart, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyInStoreKeyByStoreKeyOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  me() {
    return new ByProjectKeyInStoreKeyByStoreKeyMeRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A Customer is a person purchasing products. Carts, Orders,
   *	Comments and Reviews can be associated to a Customer.
   *
   */
  customers() {
    return new ByProjectKeyInStoreKeyByStoreKeyCustomersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Retrieves the authenticated customer.
   */
  login() {
    return new ByProjectKeyInStoreKeyByStoreKeyLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  shippingMethods() {
    return new ByProjectKeyInStoreKeyByStoreKeyShippingMethodsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	shopping-lists e.g. for wishlist support
   *
   */
  shoppingLists() {
    return new ByProjectKeyInStoreKeyByStoreKeyShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  productProjections() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductProjectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  productSelectionAssignments() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductSelectionAssignmentsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  cartDiscounts() {
    return new ByProjectKeyInStoreKeyByStoreKeyCartDiscountsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A Product Tailoring holds tailored data of Product in the Store.
   */
  productTailoring() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductTailoringRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  products() {
    return new ByProjectKeyInStoreKeyByStoreKeyProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInventoryByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/inventory/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an InventoryEntry exists for a given `id`. Returns a `200 OK` status if the InventoryEntry exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/inventory/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/inventory/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [InventoryEntryDeleted](ctp:api:type:InventoryEntryDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/inventory/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInventoryKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/inventory/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an InventoryEntry exists for a given `key`. Returns a `200 OK` status if the InventoryEntry exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/inventory/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/inventory/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [InventoryEntryDeleted](ctp:api:type:InventoryEntryDeletedMessage) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/inventory/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyInventoryRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyInventoryByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyInventoryKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/inventory',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an InventoryEntry exists for a given Query Predicate. Returns a `200 OK` status if any Inventory Entries match the Query Predicate, a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/inventory',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [InventoryEntryCreated](ctp:api:type:InventoryEntryCreatedMessage) Message.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/inventory',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyLoginRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Authenticates a global Customer not associated with a Store.
   *	For more information, see [Global versus Store-specific Customers](/../api/customers-overview#global-versus-store-specific-customers).
   *	If the Customer is registered in a Store, use the [Authenticate (sign in) Customer in Store](ctp:api:endpoint:/{projectKey}/in-store/key={storeKey}/login:POST) method.
   *
   *	Triggers [Cart merge during sign-in](/../api/customers-overview#cart-merge-during-sign-in).
   *
   *	If an account with the given credentials is not found, an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/login',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeBusinessUnitsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `id`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/business-units/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeBusinessUnitsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given `key`. Returns a `200 OK` status if the BusinessUnit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/business-units/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeBusinessUnitsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeBusinessUnitsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyMeBusinessUnitsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a BusinessUnit exists for a given Query Predicate. Returns a `200 OK` status if any BusinessUnits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Automatically assigns the Associate to the Business Unit in the default [Associate Role](ctp:api:type:AssociateRole) defined in [BusinessUnitConfiguration](ctp:api:type:BusinessUnitConfiguration). If there is no default Associate Role configured, this request fails with an [InvalidOperation](ctp:api:type:InvalidOperationError) error. When creating a Division, the Associate must have the `AddChildUnits` [Permission](ctp:api:type:Permission) in the parent unit. If the required [Permission](/projects/associate-roles#permission) is missing, an [AssociateMissingPermission](/errors#associatemissingpermission) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/business-units',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeCartsReplicateRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creates a new Cart by replicating an existing Cart or Order of the authenticated Customer.
   *	This can be useful in cases where a customer wants to cancel a recent order to make some changes or reorder a previous order.
   *
   *	The replicated Cart preserves Customer information, Line Items and Custom Line Items, Custom Fields, Discount Codes, and other settings of the Cart or Order.
   *	If the Line Items become invalid, for example, due to removed Products or Prices, they are removed from the new Cart.
   *	If the Customer switches to another Customer Group, the new Cart is updated with the new value.
   *	It has up-to-date Tax Rates, Prices, and Line Item product data and is in `Active` [CartState](ctp:api:type:CartState).
   *
   *	The new Cart does not contain Payments or Deliveries. The [State](ctp:api:type:ItemState) of Line Items and Custom Line Items is reset to `initial`.
   *
   *	In case the Cart or Order to be replicated does not belong to the authenticaed Customer, the API returns a [ResourceNotFound](ctp:api:type:ResourceNotFoundError) error
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/carts/replicate',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeCartsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `id`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/carts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeCartsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given `key`. Returns a `200 OK` status if the Cart exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/carts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeCartsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyMeCartsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeCartsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  replicate() {
    return new ByProjectKeyMeCartsReplicateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Cart exists for a given Query Predicate. Returns a `200 OK` status if any Carts match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/carts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeEmailConfirmRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This is the last step in the [email verification process of a Customer](/../api/projects/customers#email-verification-of-customer).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/email/confirm',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeLoginRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves the authenticated customer (that matches the given email/password pair).
   *
   *	If used with [an access token for an anonymous session](ctp:api:type:AnonymousSession), all Orders and Carts that belong to the `anonymousId` are assigned to the newly logged-in Customer.
   *
   *	- If the Customer does not have a Cart yet, the most recently modified anonymous cart becomes the Customer's Cart.
   *	- If the Customer already has a Cart, the most recently modified anonymous cart is handled in accordance with [AnonymousCartSignInMode](ctp:api:type:AnonymousCartSignInMode).
   *
   *	A Cart returned as part of the [CustomerSignInResult](ctp:api:type:CustomerSignInResult) is [recalculated](ctp:api:type:MyCartRecalculateAction) with up-to-date prices, taxes, discounts, and invalid line items removed.
   *
   *	If an account with the given credentials is not found, an [InvalidCredentials](ctp:api:type:InvalidCredentialsError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/login',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeOrdersQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	When creating [B2B Orders](/associates-overview#b2b-resources), the Customer must have the `CreateMyOrdersFromMyQuotes` [Permission](ctp:api:type:Permission).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *	- [AssociateMissingPermission](ctp:api:type:AssociateMissingPermissionError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/orders/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeOrdersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeOrdersRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  orderQuote() {
    return new ByProjectKeyMeOrdersQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	The Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction) for taxes to be calculated. When creating [B2B Orders](/associates-overview#b2b-resources), the Customer must have the `CreateMyOrdersFromMyCarts` [Permission](ctp:api:type:Permission).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [AssociateMissingPermission](ctp:api:type:AssociateMissingPermissionError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMePasswordResetRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This is the last step in the [password reset process of a Customer](/../api/projects/customers#password-reset-of-customer).
   *
   *	Resetting a password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=true`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/password/reset',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMePasswordRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  reset() {
    return new ByProjectKeyMePasswordResetRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	Changing the password of the Customer produces the [CustomerPasswordUpdated](ctp:api:type:CustomerPasswordUpdatedMessage) Message with `reset=false`.
   *
   *	If the current password does not match, an [InvalidCurrentPassword](ctp:api:type:InvalidCurrentPasswordError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/password',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMePaymentsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Payment exists for a given `id`. Returns a `200 OK` status if the Payment exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	This endpoint can only update a Payment when it has no [Transactions](ctp:api:type:Transaction).
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	This endpoint can only delete a Payment when it has no [Transactions](ctp:api:type:Transaction).
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMePaymentsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMePaymentsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Payment exists for a given Query Predicate. Returns a `200 OK` status if any Payments match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Payment produces the [PaymentCreated](ctp:api:type:PaymentCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeQuoteRequestsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if my QuoteRequest exists for a given `id`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeQuoteRequestsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if my QuoteRequest exists for a given `key`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeQuoteRequestsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeQuoteRequestsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyMeQuoteRequestsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if my QuoteRequest exists for a given Query Predicate. Returns a `200 OK` status if any QuoteRequests match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeQuotesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `id`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeQuotesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `key`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyMeQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given Query Predicate. Returns a `200 OK` status if any Quotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeShoppingListsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeShoppingListsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeShoppingListsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMeShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyMeShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeSignupRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	If used with an [access token for an anonymous session](ctp:api:type:AnonymousSession), all Orders and Carts that belong to the `anonymousId` are assigned to the newly created Customer.
   *
   *	Creating a Customer produces the [CustomerCreated](ctp:api:type:CustomerCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me/signup',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMeRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  emailConfirm() {
    return new ByProjectKeyMeEmailConfirmRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  password() {
    return new ByProjectKeyMePasswordRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  signup() {
    return new ByProjectKeyMeSignupRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  login() {
    return new ByProjectKeyMeLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  activeCart() {
    return new ByProjectKeyMeActiveCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	MyBusinessUnit creates and provides access to Business Units scoped to a specific user.
   */
  businessUnits() {
    return new ByProjectKeyMeBusinessUnitsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyMeCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	An order can be created from a cart, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyMeOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	The My Payments endpoint creates and provides access to payments scoped to a specific user.
   */
  payments() {
    return new ByProjectKeyMePaymentsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	The My Quote Requests endpoint creates and provides access to Quote Requests scoped to a specific user.
   */
  quoteRequests() {
    return new ByProjectKeyMeQuoteRequestsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	The My Quote endpoint provides access to Quotes scoped to a specific user.
   */
  quotes() {
    return new ByProjectKeyMeQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	The My Shopping Lists endpoint creates and provides access to Shopping Lists scoped to a specific user.
   */
  shoppingLists() {
    return new ByProjectKeyMeShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/me',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMessagesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/messages/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Message exists for a given `id`. Returns a `200 OK` status if the Message exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/messages/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyMessagesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withId(childPathArgs) {
    return new ByProjectKeyMessagesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	Deprecated scope: `view_orders:{projectKey}`
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/messages',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Message exists for a given Query Predicate. Returns a `200 OK` status if any Messages match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/messages',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyOrdersEditsByIDApplyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Applying an OrderEdit produces the [OrderEditApplied](ctp:api:type:OrderEditAppliedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/edits/{ID}/apply',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyOrdersEditsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  apply() {
    return new ByProjectKeyOrdersEditsByIDApplyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders/edits/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an OrderEdit exists for a given `id`. Returns a `200 OK` status if the OrderEdit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/edits/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/edits/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/orders/edits/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyOrdersEditsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders/edits/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an OrderEdit exists for a given `key`. Returns a `200 OK` status if the OrderEdit exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/edits/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/edits/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/orders/edits/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyOrdersEditsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyOrdersEditsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyOrdersEditsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders/edits',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an OrderEdit exists for a given Query Predicate. Returns a `200 OK` status if any OrderEdits match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/edits',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	You can either create multiple Order Edits for an Order and apply them sequentially to an Order, or create multiple Order Edits parallelly (as alternatives to each other) and apply one of them to the Order.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/edits',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyOrdersImportRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Importing an Order produces the [Order Imported](ctp:api:type:OrderImportedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/import',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyOrdersQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [InvalidOperation](ctp:api:type:InvalidOperationError)
   *	- [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyOrdersSearchRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/search',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Checks whether a search index for the Project's Orders exists.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/search',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyOrdersByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `id`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/orders/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyOrdersOrderNumberByOrderNumberRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given `orderNumber`. Returns a `200 OK` status if the Order exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deleting an Order produces the [OrderDeleted](ctp:api:type:OrderDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/orders/order-number={orderNumber}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyOrdersRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  importOrder() {
    return new ByProjectKeyOrdersImportRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  orderQuote() {
    return new ByProjectKeyOrdersQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withOrderNumber(childPathArgs) {
    return new ByProjectKeyOrdersOrderNumberByOrderNumberRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	OrderEdit are containers for financial changes after an Order has been placed.
   */
  edits() {
    return new ByProjectKeyOrdersEditsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyOrdersByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	This endpoint provides high performance search queries over Orders. The order search allows searching through all orders (currently supporting a limit of the 10.000.000 newest orders) in your project.
   *
   */
  search() {
    return new ByProjectKeyOrdersSearchRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if an Order exists for a given Query Predicate. Returns a `200 OK` status if any Orders match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Before you create an Order, the Cart must have a [shipping address set](ctp:api:type:CartSetShippingAddressAction).
   *	The shipping address is used for tax calculation for a Cart with `Platform` [TaxMode](ctp:api:type:TaxMode).
   *
   *	Creating an Order produces the [OrderCreated](ctp:api:type:OrderCreatedMessage) Message.
   *
   *	Specific Error Codes:
   *
   *	- [OutOfStock](ctp:api:type:OutOfStockError)
   *	- [PriceChanged](ctp:api:type:PriceChangedError)
   *	- [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError)
   *	- [ShippingMethodDoesNotMatchCart](ctp:api:type:ShippingMethodDoesNotMatchCartError)
   *	- [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError)
   *	- [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError)
   *	- [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError)
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/orders',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyPaymentsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Payment exists for a given `id`. Returns a `200 OK` status if the Payment exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/payments/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyPaymentsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/payments/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Payment exists for a given `key`. Returns a `200 OK` status if the Payment exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/payments/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/payments/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/payments/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyPaymentsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyPaymentsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyPaymentsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Payment exists for a given Query Predicate. Returns a `200 OK` status if any Payments match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Creating a Payment produces the [PaymentCreated](ctp:api:type:PaymentCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/payments',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductDiscountsMatchingRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This endpoint can be used to simulate which Product Discounts would be applied if a specified Product Variant had a specified Price.
   *	Given Product and Product Variant IDs and a Price, this endpoint will return the [ProductDiscount](ctp:api:type:ProductDiscount) that would have been applied to that Price.
   *
   *	If a Product Discount could not be found that could be applied to the Price of a Product Variant, a [NoMatchingProductDiscountFound](ctp:api:type:NoMatchingProductDiscountFoundError) error is returned.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-discounts/matching',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductDiscountsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductDiscount exists for a given `id`. Returns a `200 OK` status if the ProductDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-discounts/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductDiscountsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductDiscount exists for a given `key`. Returns a `200 OK` status if the ProductDiscount exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-discounts/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductDiscountsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  matching() {
    return new ByProjectKeyProductDiscountsMatchingRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductDiscountsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductDiscountsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductDiscount exists for a given Query Predicate. Returns a `200 OK` status if any ProductDiscounts match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-discounts',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductProjectionsSearchRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Product Projection Search
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-projections/search',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Product Projection Search
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-projections/search',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductProjectionsSuggestRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-projections/suggest',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductProjectionsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) by its ID. When used with an API Client that has the `view_published_products:{projectKey}` scope, this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-projections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if the current or staged representation of a Product exists for a given `id`. Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-projections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductProjectionsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Gets the current or staged representation of a [Product](ctp:api:type:Product) found by Key.
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope,
   *	this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-projections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if the current or staged representation of a Product exists for a given `key`. Returns a `200 OK` status if the ProductProjection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-projections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductProjectionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This endpoint provides high performance search queries over ProductProjections. The query result contains the
   *	ProductProjections for which at least one ProductVariant matches the search query. This means that variants can
   *	be included in the result also for which the search query does not match. To determine which ProductVariants match
   *	the search query, the returned ProductProjections include the additional field isMatchingVariant.
   *
   */
  search() {
    return new ByProjectKeyProductProjectionsSearchRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	The source of data for suggestions is the searchKeyword field in a product
   */
  suggest() {
    return new ByProjectKeyProductProjectionsSuggestRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductProjectionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductProjectionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	Use the Product Projections query endpoint to get the current or staged representations of Products.
   *	When used with an API Client that has the `view_published_products:{projectKey}` scope,
   *	this endpoint only returns published (current) Product Projections.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-projections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if the current or staged representation of a Product exists for a given Query Predicate. Returns a `200 OK` status if any ProductProjections match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-projections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductSelectionsByIDProductsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-selections/{ID}/products',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductSelectionsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  products() {
    return new ByProjectKeyProductSelectionsByIDProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-selections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductSelection exists for a given `id`. Returns a `200 OK` status if the ProductSelection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-selections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-selections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deletion will only succeed if the Product Selection is not assigned to any [Store](ctp:api:type:Store).
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-selections/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductSelectionsKeyByKeyProductsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-selections/key={key}/products',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductSelectionsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  products() {
    return new ByProjectKeyProductSelectionsKeyByKeyProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-selections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductSelection exists for a given `key`. Returns a `200 OK` status if the ProductSelection exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-selections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-selections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Deletion will only succeed if the Product Selection is not assigned to any [Store](ctp:api:type:Store).
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-selections/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductSelectionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductSelectionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductSelectionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-selections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductSelection exists for a given Query Predicate. Returns a `200 OK` status if any ProductSelections match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-selections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-selections',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductTailoringByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-tailoring/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-tailoring/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Generates the [ProductTailoringDeleted](ctp:api:type:ProductTailoringDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-tailoring/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductTailoringKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-tailoring/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-tailoring/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Generates the [ProductTailoringDeleted](ctp:api:type:ProductTailoringDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-tailoring/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductTailoringRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductTailoringKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductTailoringByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Generates the [ProductTailoringCreated](ctp:api:type:ProductTailoringCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-tailoring',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductTypesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductType exists for a given `id`. Returns a `200 OK` status if the ProductType exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductTypesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductType exists for a given `key`. Returns a `200 OK` status if the ProductType exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/product-types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductTypesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductTypesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductTypesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/product-types',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ProductType exists for a given Query Predicate. Returns a `200 OK` status if any ProductTypes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/product-types',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/product-types',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductsSearchRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/products/search',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductsByIDImagesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Upload a JPEG, PNG and GIF file to a [ProductVariant](ctp:api:type:ProductVariant). The maximum file size of the image is 10MB. `variant` or `sku` is required to update a specific ProductVariant. The image is uploaded to the Master Variant if `variant` or `sku` are not included. Produces the [ProductImageAdded](/projects/messages#product-image-added) Message when the `Small` version of the image has been uploaded to the CDN.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/products/{ID}/images',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductsByIDProductSelectionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/products/{ID}/product-selections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  images() {
    return new ByProjectKeyProductsByIDImagesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  productSelections() {
    return new ByProjectKeyProductsByIDProductSelectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/products/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Product exists for a given `id`. Returns a `200 OK` status if the Product exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/products/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   *
   *	A failed response can return a [DuplicatePriceScope](ctp:api:type:DuplicatePriceScopeError), [DuplicateVariantValues](ctp:api:type:DuplicateVariantValuesError), [DuplicateAttributeValue](ctp:api:type:DuplicateAttributeValueError), or [DuplicateAttributeValues](ctp:api:type:DuplicateAttributeValuesError) error.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/products/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   *	Produces the [ProductDeleted](/projects/messages#product-deleted) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/products/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductsKeyByKeyProductSelectionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/products/key={key}/product-selections',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  productSelections() {
    return new ByProjectKeyProductsKeyByKeyProductSelectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/products/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Product exists for a given `key`. Returns a `200 OK` status if the Product exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/products/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	A failed response can return a [DuplicatePriceScope](ctp:api:type:DuplicatePriceScopeError), [DuplicateVariantValues](ctp:api:type:DuplicateVariantValuesError), [DuplicateAttributeValue](ctp:api:type:DuplicateAttributeValueError), or [DuplicateAttributeValues](ctp:api:type:DuplicateAttributeValuesError) error.
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/products/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   *	Produces the [ProductDeleted](/projects/messages#product-deleted) Message.
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/products/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyProductsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyProductsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyProductsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	This endpoint provides high-performance search queries over Products. Product Search allows searching through all products with a current projection in your Project.
   *
   */
  search() {
    return new ByProjectKeyProductsSearchRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }

  /**
   *	If [Price selection](ctp:api:type:ProductPriceSelection) query parameters are provided, the selected Prices are added to the response.
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/products',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Product exists for a given Query Predicate. Returns a `200 OK` status if any Products match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/products',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	To create a new Product, send a representation that is going to become the initial _staged_ and _current_ representation of the new Product in the catalog.
   *	If [Price Selection](ctp:api:type:ProductPriceSelection) query parameters are provided, selected Prices will be added to the response.
   *	Produces the [ProductCreated](/projects/messages#product-created) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/products',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyQuoteRequestsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given `id`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/quote-requests/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyQuoteRequestsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given `key`. Returns a `200 OK` status if the QuoteRequest exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/quote-requests/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyQuoteRequestsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyQuoteRequestsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyQuoteRequestsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a QuoteRequest exists for a given Query Predicate. Returns a `200 OK` status if any QuoteRequests match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quote-requests',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyQuotesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `id`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyQuotesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given `key`. Returns a `200 OK` status if the Quote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Quote exists for a given Query Predicate. Returns a `200 OK` status if any Quotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyReviewsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/reviews/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Review exists for a given `id`. Returns a `200 OK` status if the Review exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/reviews/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/reviews/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/reviews/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyReviewsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/reviews/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Review exists for a given `key`. Returns a `200 OK` status if the Review exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/reviews/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/reviews/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/reviews/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyReviewsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyReviewsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyReviewsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/reviews',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Review exists for a given Query Predicate. Returns a `200 OK` status if any Reviews match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/reviews',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/reviews',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyShippingMethodsMatchingCartLocationRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves all the ShippingMethods that can ship to the given [Location](ctp:api:type:Location)
   *	with a `predicate` that matches the given Cart.
   *	Each ShippingMethod contains exactly one ShippingRate with the flag `isMatching` set to `true`.
   *	This ShippingRate is used when the ShippingMethod is [added to the Cart](ctp:api:type:CartSetShippingMethodAction).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/matching-cart-location',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod that can ship to the given [Location](ctp:api:type:Location) exists for the given Cart. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/matching-cart-location',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyShippingMethodsMatchingCartRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves all the ShippingMethods that can ship to the shipping address of the given Cart.
   *	Each ShippingMethod contains exactly one ShippingRate with the flag `isMatching` set to `true`.
   *	This ShippingRate is used when the ShippingMethod is [added to the Cart](ctp:api:type:CartSetShippingMethodAction).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/matching-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod exists for the given Cart. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/matching-cart',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyShippingMethodsMatchingLocationRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves all the ShippingMethods that can ship to the given [Location](/projects/zones#location).
   *	ShippingMethods that have a `predicate` defined are automatically disqualified.
   *	If the `currency` parameter is given, then the ShippingMethods must also have a rate defined in the specified currency.
   *	Each ShippingMethod contains at least one ShippingRate with the flag `isMatching` set to `true`.
   *	If the `currency` parameter is given, exactly one ShippingRate will contain it.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/matching-location',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod that can ship to the given [Location](ctp:api:type:Location) exists. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/matching-location',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyShippingMethodsMatchingOrdereditRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	Retrieves all the ShippingMethods that can ship to the given [Location](ctp:api:type:Location) for an [OrderEdit](ctp:api:type:OrderEdit).
   *
   *	If the OrderEdit preview cannot be generated, an [EditPreviewFailed](ctp:api:type:EditPreviewFailedError) error is returned.
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/matching-orderedit',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod that can ship to the given [Location](ctp:api:type:Location) exists for the given [OrderEdit](ctp:api:type:OrderEdit). Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/matching-orderedit',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyShippingMethodsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod exists for a given `id`. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shipping-methods/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/shipping-methods/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyShippingMethodsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod exists for a given `key`. Returns a `200 OK` status if the ShippingMethod exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shipping-methods/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/shipping-methods/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyShippingMethodsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyShippingMethodsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Get ShippingMethods for a cart
   */
  matchingCart() {
    return new ByProjectKeyShippingMethodsMatchingCartRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Get ShippingMethods for a cart and location
   */
  matchingCartLocation() {
    return new ByProjectKeyShippingMethodsMatchingCartLocationRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Get ShippingMethods for an order edit
   */
  matchingOrderedit() {
    return new ByProjectKeyShippingMethodsMatchingOrdereditRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Get ShippingMethods for a location
   */
  matchingLocation() {
    return new ByProjectKeyShippingMethodsMatchingLocationRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyShippingMethodsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shipping-methods',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShippingMethod exists for a given Query Predicate. Returns a `200 OK` status if any ShippingMethods match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shipping-methods',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shipping-methods',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyShoppingListsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `id`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/shopping-lists/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyShoppingListsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given `key`. Returns a `200 OK` status if the ShoppingList exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/shopping-lists/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyShoppingListsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyShoppingListsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyShoppingListsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a ShoppingList exists for a given Query Predicate. Returns a `200 OK` status if any ShoppingLists match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/shopping-lists',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStagedQuotesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/staged-quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StagedQuote exists for a given `id`. Returns a `200 OK` status if the StagedQuote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/staged-quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/staged-quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/staged-quotes/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStagedQuotesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/staged-quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StagedQuote exists for a given `key`. Returns a `200 OK` status if the StagedQuote exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/staged-quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/staged-quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/staged-quotes/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStagedQuotesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyStagedQuotesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyStagedQuotesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/staged-quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StagedQuote exists for a given Query Predicate. Returns a `200 OK` status if any StagedQuotes match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/staged-quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/staged-quotes',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStandalonePricesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/standalone-prices/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StandalonePrice exists for a given `id`. Returns a `200 OK` status if the StandalonePrice exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/standalone-prices/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/standalone-prices/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [StandalonePriceDeleted](ctp:api:type:StandalonePriceDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/standalone-prices/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStandalonePricesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/standalone-prices/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StandalonePrice exists for a given `key`. Returns a `200 OK` status if the StandalonePrice exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/standalone-prices/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/standalone-prices/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [StandalonePriceDeleted](ctp:api:type:StandalonePriceDeletedMessage) Message.
   *
   */
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/standalone-prices/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStandalonePricesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyStandalonePricesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyStandalonePricesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/standalone-prices',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a StandalonePrice exists for a given Query Predicate. Returns a `200 OK` status if any StandalonePrices match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/standalone-prices',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Produces the [StandalonePriceCreated](ctp:api:type:StandalonePriceCreatedMessage) Message.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/standalone-prices',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStatesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/states/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a State exists for a given `id`. Returns a `200 OK` status if the State exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/states/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/states/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/states/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStatesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/states/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a State exists for a given `key`. Returns a `200 OK` status if the State exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/states/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/states/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/states/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStatesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyStatesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyStatesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/states',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a State exists for a given Query Predicate. Returns a `200 OK` status if any States match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/states',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/states',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStoresByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/stores/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Store exists for a given `id`. Returns a `200 OK` status if the Store exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/stores/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/stores/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/stores/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStoresKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/stores/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Store exists for a given `key`. Returns a `200 OK` status if the Store exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/stores/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/stores/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/stores/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyStoresRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyStoresKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyStoresByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/stores',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Store exists for a given Query Predicate. Returns a `200 OK` status if any Stores match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/stores',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/stores',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeySubscriptionsByIDHealthRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  /**
   *	This endpoint can be polled by a monitoring or alerting system that checks the health of your Subscriptions. To ease integration with such systems this endpoint does not require [Authorization](/../api/authorization).
   *
   */
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/subscriptions/{ID}/health',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeySubscriptionsByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withIdHealth() {
    return new ByProjectKeySubscriptionsByIDHealthRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/subscriptions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Subscription exists for a given `id`. Returns a `200 OK` status if the Subscription exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/subscriptions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/subscriptions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/subscriptions/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeySubscriptionsKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/subscriptions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Subscription exists for a given `key`. Returns a `200 OK` status if the Subscription exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/subscriptions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/subscriptions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/subscriptions/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeySubscriptionsRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeySubscriptionsKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeySubscriptionsByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/subscriptions',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Subscription exists for a given Query Predicate. Returns a `200 OK` status if any Subscriptions match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/subscriptions',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	A test message is sent to ensure the correct configuration of the Destination. If the message cannot be delivered, the Subscription will not be created. The payload of the test message is a notification of type [ResourceCreated](/../api/projects/subscriptions#resourcecreateddeliverypayload) for the `resourceTypeId` `subscription`.
   *
   */
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/subscriptions',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyTaxCategoriesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/tax-categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a TaxCategory exists for a given `id`. Returns a `200 OK` status if the TaxCategory exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/tax-categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/tax-categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/tax-categories/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyTaxCategoriesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/tax-categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a TaxCategory exists for a given `key`. Returns a `200 OK` status if the Tax Category exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/tax-categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/tax-categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/tax-categories/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyTaxCategoriesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyTaxCategoriesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyTaxCategoriesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/tax-categories',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a TaxCategory exists for a given Query Predicate. Returns a `200 OK` status if any TaxCategories match the Query Predicate, or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/tax-categories',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/tax-categories',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyTypesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Type exists for a given `id`. Returns a `200 OK` status if the Type exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/types/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyTypesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Type exists for a given `key`. Returns a `200 OK` status if the Type exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/types/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyTypesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyTypesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyTypesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/types',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Type exists for a given Query Predicate. Returns a `200 OK` status if any Types match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/types',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/types',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyZonesByIDRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/zones/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Zone exists for a given `id`. Returns a `200 OK` status if the Zone exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/zones/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/zones/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/zones/{ID}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyZonesKeyByKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/zones/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Zone exists for a given `key`. Returns a `200 OK` status if the Zone exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/zones/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/zones/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
  delete(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'DELETE',
      uriTemplate: '/{projectKey}/zones/key={key}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyZonesRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  withKey(childPathArgs) {
    return new ByProjectKeyZonesKeyByKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  withId(childPathArgs) {
    return new ByProjectKeyZonesByIDRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}/zones',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Zone exists for a given Query Predicate. Returns a `200 OK` status if any Zones match the Query Predicate or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}/zones',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}/zones',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      queryParams: methodArgs?.queryArgs,
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate raml_file_path -o output_path -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */
/**
 **/
class ByProjectKeyRequestBuilder {
  constructor(args) {
    this.args = args;
  }
  asAssociate() {
    return new ByProjectKeyAsAssociateRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	An Associate Role enables permissions over a Business Unit to an Associate.
   */
  associateRoles() {
    return new ByProjectKeyAssociateRolesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A Business Unit can represent a Company or a Division.
   */
  businessUnits() {
    return new ByProjectKeyBusinessUnitsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Categories are used to organize products in a hierarchical structure.
   */
  categories() {
    return new ByProjectKeyCategoriesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A shopping cart holds product variants and can be ordered.
   */
  carts() {
    return new ByProjectKeyCartsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Cart discounts are used to change the prices of different elements within a cart.
   */
  cartDiscounts() {
    return new ByProjectKeyCartDiscountsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Channels represent a source or destination of different entities. They can be used to model warehouses or stores.
   *
   */
  channels() {
    return new ByProjectKeyChannelsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A Customer is a person purchasing products. Carts, Orders, Quotes, Reviews and Payments can be associated to a Customer.
   *
   */
  customers() {
    return new ByProjectKeyCustomersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	customer-groups are used to evaluate products and channels.
   */
  customerGroups() {
    return new ByProjectKeyCustomerGroupsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Store custom JSON values.
   */
  customObjects() {
    return new ByProjectKeyCustomObjectsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Discount Codes can be added to a discount-code to enable certain discount-code discounts.
   */
  discountCodes() {
    return new ByProjectKeyDiscountCodesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	commercetools Composable Commerce provides a GraphQL API
   */
  graphql() {
    return new ByProjectKeyGraphqlRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Inventory allows you to track stock quantities.
   */
  inventory() {
    return new ByProjectKeyInventoryRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Retrieves the authenticated customer.
   */
  login() {
    return new ByProjectKeyLoginRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A message represents a change or an action performed on a resource (like an Order or a Product).
   */
  messages() {
    return new ByProjectKeyMessagesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	An order can be created from a order, usually after a checkout process has been completed.
   */
  orders() {
    return new ByProjectKeyOrdersRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Payments hold information about the current state of receiving and/or refunding money
   */
  payments() {
    return new ByProjectKeyPaymentsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Products themselves are not sellable. Instead, they act as a parent structure for sellable Product Variants.
   *
   */
  products() {
    return new ByProjectKeyProductsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Product discounts are used to change certain product prices.
   */
  productDiscounts() {
    return new ByProjectKeyProductDiscountsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A projected representation of a product shows the product with its current or staged data. The current or staged
   *	representation of a product in a catalog is called a product projection.
   *
   */
  productProjections() {
    return new ByProjectKeyProductProjectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Manage individual Store assortments through Product Selections.
   *
   *	After you have created Product Selections and populated them with Products,
   *	you can manage Store assortments by assigning Product Selections to Stores.
   *	Product Selections may be used by a single Store or shared across several Stores.
   *
   *	As a good practice, we recommend first creating Products in the project, and then creating Product Selection.
   *
   */
  productSelections() {
    return new ByProjectKeyProductSelectionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Product tailoring are used to contextualize product data for specific stores.
   */
  productTailoring() {
    return new ByProjectKeyProductTailoringRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Product Types are used to describe common characteristics, most importantly common custom attributes,
   *	of many concrete products.
   *
   */
  productTypes() {
    return new ByProjectKeyProductTypesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A quote holds the negotiated offer.
   */
  quotes() {
    return new ByProjectKeyQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A request for a Quote holds product variants and can be ordered.
   */
  quoteRequests() {
    return new ByProjectKeyQuoteRequestsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A staged quote holds the negotiation between the [Buyer](/../api/quotes-overview#buyer) and the [Seller](/../api/quotes-overview#seller).
   */
  stagedQuotes() {
    return new ByProjectKeyStagedQuotesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Reviews are used to evaluate products and channels.
   */
  reviews() {
    return new ByProjectKeyReviewsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	ShippingMethods define where orders can be shipped and what the costs are.
   */
  shippingMethods() {
    return new ByProjectKeyShippingMethodsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	shopping-lists e.g. for wishlist support
   */
  shoppingLists() {
    return new ByProjectKeyShoppingListsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	commercetools Composable Commerce allows you to model states of certain objects, such as orders, line items, products,
   *	reviews, and payments in order to define finite state machines reflecting the business logic you'd like to
   *	implement.
   *
   */
  states() {
    return new ByProjectKeyStatesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Subscriptions allow you to be notified of new messages or changes via a Message Queue of your choice
   */
  subscriptions() {
    return new ByProjectKeySubscriptionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Tax Categories define how products are to be taxed in different countries.
   */
  taxCategories() {
    return new ByProjectKeyTaxCategoriesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Types define custom fields that are used to enhance resources as you need.
   */
  types() {
    return new ByProjectKeyTypesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Zones allow defining ShippingRates for specific Locations.
   */
  zones() {
    return new ByProjectKeyZonesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  me() {
    return new ByProjectKeyMeRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Extend the behavior of an API with your business logic
   */
  extensions() {
    return new ByProjectKeyExtensionsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Manage your API Clients via an API. Useful for Infrastructure-as-Code tooling, and regularly rotating API secrets.
   *
   */
  apiClients() {
    return new ByProjectKeyApiClientsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Stores let you model the context your customers shop in.
   */
  stores() {
    return new ByProjectKeyStoresRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  inStoreKeyWithStoreKeyValue(childPathArgs) {
    return new ByProjectKeyInStoreKeyByStoreKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	A standalone price assigns a price to a product variant for a given scope. The API will use the standalone prices associated with a Product if its field [`priceMode`](/projects/products#pricemode) is set to `Standalone` [ProductPriceMode](ctp:api:type:ProductPriceModeEnum).
   */
  standalonePrices() {
    return new ByProjectKeyStandalonePricesRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  inBusinessUnitKeyWithBusinessUnitKeyValue(childPathArgs) {
    return new ByProjectKeyInBusinessUnitKeyByBusinessUnitKeyRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs,
        ...childPathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  /**
   *	Attribute groups ... TODO
   */
  attributeGroups() {
    return new ByProjectKeyAttributeGroupsRequestBuilder({
      pathArgs: {
        ...this.args.pathArgs
      },
      executeRequest: this.args.executeRequest,
      baseUri: this.args.baseUri
    });
  }
  get(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'GET',
      uriTemplate: '/{projectKey}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  /**
   *	Checks if a Project exists for a given `projectKey`. Returns a `200 OK` status if the Project exists or a `404 Not Found` otherwise.
   */
  head(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'HEAD',
      uriTemplate: '/{projectKey}',
      pathVariables: this.args.pathArgs,
      headers: {
        ...methodArgs?.headers
      }
    }, this.args.executeRequest);
  }
  post(methodArgs) {
    return new ApiRequest({
      baseUri: this.args.baseUri,
      method: 'POST',
      uriTemplate: '/{projectKey}',
      pathVariables: this.args.pathArgs,
      headers: {
        'Content-Type': 'application/json',
        ...methodArgs?.headers
      },
      body: methodArgs?.body
    }, this.args.executeRequest);
  }
}

class ApiRoot {
  constructor(args) {
    _defineProperty(this, "executeRequest", void 0);
    _defineProperty(this, "baseUri", void 0);
    this.executeRequest = args.executeRequest;
    this.baseUri = args.baseUri || 'https://api.europe-west1.gcp.commercetools.com';
  }

  /**
   *	The Project endpoint is used to retrieve certain information from a project.
   */
  withProjectKey(childPathArgs) {
    return new ByProjectKeyRequestBuilder({
      pathArgs: {
        ...childPathArgs
      },
      executeRequest: this.executeRequest,
      baseUri: this.baseUri
    });
  }
}

/**
 * Code generated by [commercetools RMF-Codegen](https://github.com/commercetools/rmf-codegen). DO NOT EDIT.
 * Please don't change this file manually but run `rmf-codegen generate <raml_file_path> -o <output_path> -t typescript_client` to update it.
 * For more information about the commercetools platform APIs, visit https://docs.commercetools.com/.
 */

const createExecutorFromMiddlewares = (executor, midds) => {
  if (!midds || midds.length == 0) {
    return executor;
  }
  const reduced = midds.reduce(reduceMiddleware);
  return middlewareToExecutor(reduced, executor);
};
function reduceMiddleware(middleware1, middleware2) {
  return (request, executor) => middleware1(request, middlewareToExecutor(middleware2, executor));
}
function middlewareToExecutor(middleware, executor) {
  return request => middleware(request, executor);
}

function createApiBuilderFromCtpClient(ctpClient, baseUri) {
  return new ApiRoot({
    executeRequest: ctpClient.execute,
    baseUri: baseUri
  });
}




/***/ }),

/***/ "./node_modules/@commercetools/sdk-client-v2/dist/commercetools-sdk-client-v2.browser.esm.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@commercetools/sdk-client-v2/dist/commercetools-sdk-client-v2.browser.esm.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClientBuilder: () => (/* binding */ ClientBuilder),
/* harmony export */   Process: () => (/* binding */ process$1),
/* harmony export */   createAuthForAnonymousSessionFlow: () => (/* binding */ createAuthMiddlewareForAnonymousSessionFlow$1),
/* harmony export */   createAuthForClientCredentialsFlow: () => (/* binding */ createAuthMiddlewareForClientCredentialsFlow$1),
/* harmony export */   createAuthForPasswordFlow: () => (/* binding */ createAuthMiddlewareForPasswordFlow$1),
/* harmony export */   createAuthForRefreshTokenFlow: () => (/* binding */ createAuthMiddlewareForRefreshTokenFlow$1),
/* harmony export */   createAuthWithExistingToken: () => (/* binding */ createAuthMiddlewareWithExistingToken$1),
/* harmony export */   createClient: () => (/* binding */ createClient),
/* harmony export */   createCorrelationIdMiddleware: () => (/* binding */ createCorrelationIdMiddleware),
/* harmony export */   createHttpClient: () => (/* binding */ createHttpMiddleware),
/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),
/* harmony export */   createQueueMiddleware: () => (/* binding */ createQueueMiddleware),
/* harmony export */   createUserAgentMiddleware: () => (/* binding */ createUserAgentMiddleware),
/* harmony export */   getErrorByCode: () => (/* binding */ getErrorByCode)
/* harmony export */ });
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer/ */ "./node_modules/buffer/index.js");



function toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function isDefined(value) {
  return typeof value !== 'undefined' && value !== null;
}
function clean(value) {
  if (!isDefined(value)) return '';
  if (typeof value == 'string') return value;
  return Object.fromEntries(Object.entries(value).filter(([_, value]) => ![null, undefined, ''].includes(value)));
}
function urlParser(url) {
  const object = {};
  const data = new URLSearchParams(url);
  for (let x of data.keys()) {
    if (data.getAll(x).length > 1) {
      object[x] = data.getAll(x);
    } else {
      object[x] = data.get(x);
    }
  }
  return object;
}
function urlStringifier(object) {
  object = clean(object);
  if (!object) return '';
  const params = new URLSearchParams(object);
  for (const [key, value] of Object.entries(object)) {
    if (Array.isArray(value)) {
      params.delete(key);
      value.filter(isDefined).forEach(v => params.append(key, v));
    }
  }
  return params.toString();
}
function parseURLString(url, parser = urlParser) {
  return parser(url);
}
function stringifyURLString(object, stringifier = urlStringifier) {
  return stringifier(object);
}

var METHODS = ['ACL', 'BIND', 'CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LINK', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCALENDAR', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REBIND', 'REPORT', 'SEARCH', 'SOURCE', 'SUBSCRIBE', 'TRACE', 'UNBIND', 'UNLINK', 'UNLOCK', 'UNSUBSCRIBE'];

/**
 * @throws {Error}
 */
function validate(funcName, request, options = {
  allowedMethods: METHODS
}) {
  if (!request) throw new Error(`The "${funcName}" function requires a "Request" object as an argument. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
  if (typeof request.uri !== 'string') throw new Error(`The "${funcName}" Request object requires a valid uri. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
  if (!options.allowedMethods.includes(request.method)) throw new Error(`The "${funcName}" Request object requires a valid method. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest`);
}

let _options;
const PAGE_LIMIT = 20;
function compose(...funcs) {
  funcs = funcs.filter(func => typeof func === 'function');
  if (funcs.length === 1) return funcs[0];
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
function process$1(request, fn, processOpt) {
  validate('process', request, {
    allowedMethods: ['GET']
  });
  if (typeof fn !== 'function') throw new Error('The "process" function accepts a "Function" as a second argument that returns a Promise. See https://commercetools.github.io/nodejs/sdk/api/sdkClient.html#processrequest-processfn-options');

  // Set default process options
  const opt = {
    limit: PAGE_LIMIT,
    // defaults
    total: Number.POSITIVE_INFINITY,
    accumulate: true,
    ...processOpt
  };
  return new Promise((resolve, reject) => {
    let _path,
      _queryString = '';
    if (request && request.uri) {
      const [path, queryString] = request.uri.split('?');
      _path = path;
      _queryString = queryString;
    }
    // const requestQuery = { ...qs.parse(_queryString) }
    // const requestQuery = { ...Object.fromEntries(new URLSearchParams(_queryString)) }
    const requestQuery = {
      ...parseURLString(_queryString)
    };
    const query = {
      // defaults
      limit: opt.limit,
      // merge given query params
      ...requestQuery
    };
    let hasFirstPageBeenProcessed = false;
    let itemsToGet = opt.total;
    const processPage = async (lastId, acc = []) => {
      // Use the lesser value between limit and itemsToGet in query
      const limit = query.limit < itemsToGet ? query.limit : itemsToGet;
      // const originalQueryString = qs.stringify({ ...query, limit }, qsOptions)
      const originalQueryString = stringifyURLString({
        ...query,
        limit
      });
      const enhancedQuery = {
        sort: opt.sort || 'id asc',
        withTotal: false,
        ...(lastId ? {
          where: `id > "${lastId}"`
        } : {})
      };

      // const enhancedQueryString = qs.stringify(enhancedQuery, qsOptions)
      const enhancedQueryString = stringifyURLString(enhancedQuery);
      const enhancedRequest = {
        ...request,
        uri: `${_path}?${enhancedQueryString}&${originalQueryString}`
      };
      try {
        const payload = await createClient(_options).execute(enhancedRequest);
        const {
          results,
          count: resultsLength
        } = payload.body;
        if (!resultsLength && hasFirstPageBeenProcessed) {
          return resolve(acc || []);
        }
        const result = await Promise.resolve(fn(payload));
        let accumulated = [];
        hasFirstPageBeenProcessed = true;
        if (opt.accumulate) accumulated = acc.concat(result || []);
        itemsToGet -= resultsLength;
        // If there are no more items to get, it means the total number
        // of items in the original request have been fetched so we
        // resolve the promise.
        // Also, if we get less results in a page then the limit set it
        // means that there are no more pages and that we can finally
        // resolve the promise.
        if (resultsLength < query.limit || !itemsToGet) {
          return resolve(accumulated || []);
        }
        const last = results[resultsLength - 1];
        const newLastId = last && last.id;
        processPage(newLastId, accumulated);
      } catch (error) {
        reject(error);
      }
    };

    // Start iterating through pages
    processPage();
  });
}
function createClient(options) {
  _options = options;
  if (!options) throw new Error('Missing required options');
  if (options.middlewares && !Array.isArray(options.middlewares)) throw new Error('Middlewares should be an array');
  if (!options.middlewares || !Array.isArray(options.middlewares) || !options.middlewares.length) throw new Error('You need to provide at least one middleware');
  return {
    /**
     * Given a request object,
     */
    process: process$1,
    execute(request) {
      validate('exec', request);
      return new Promise((resolve, reject) => {
        const resolver = (rq, rs) => {
          // Note: pick the promise `resolve` and `reject` function from
          // the response object. This is not necessary the same function
          // given from the `new Promise` constructor, as middlewares could
          // override those functions for custom behaviours.
          if (rs.error) rs.reject(rs.error);else {
            const resObj = {
              body: rs.body || {},
              statusCode: rs.statusCode
            };
            if (rs.headers) resObj.headers = rs.headers;
            if (rs.request) resObj.request = rs.request;
            rs.resolve(resObj);
          }
        };
        const dispatch = compose(...options.middlewares)(resolver);
        dispatch(request,
        // Initial response shape
        {
          resolve,
          reject,
          body: undefined,
          error: undefined
        });
      });
    }
  };
}

function buildRequestForClientCredentialsFlow(options) {
  if (!options) throw new Error('Missing required options');
  if (!options.host) throw new Error('Missing required option (host)');
  if (!options.projectKey) throw new Error('Missing required option (projectKey)');
  if (!options.credentials) throw new Error('Missing required option (credentials)');
  const {
    clientId,
    clientSecret
  } = options.credentials;
  if (!(clientId && clientSecret)) throw new Error('Missing required credentials (clientId, clientSecret)');
  const scope = options.scopes ? options.scopes.join(' ') : undefined;
  const basicAuth = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
  // This is mostly useful for internal testing purposes to be able to check
  // other oauth endpoints.
  const oauthUri = options.oauthUri || '/oauth/token';
  const url = options.host.replace(/\/$/, '') + oauthUri;
  const body = `grant_type=client_credentials${scope ? `&scope=${scope}` : ''}`;
  return {
    basicAuth,
    url,
    body
  };
}
function buildRequestForPasswordFlow(options) {
  if (!options) throw new Error('Missing required options');
  if (!options.host) throw new Error('Missing required option (host)');
  if (!options.projectKey) throw new Error('Missing required option (projectKey)');
  if (!options.credentials) throw new Error('Missing required option (credentials)');
  const {
    clientId,
    clientSecret,
    user
  } = options.credentials;
  const pKey = options.projectKey;
  if (!(clientId && clientSecret && user)) throw new Error('Missing required credentials (clientId, clientSecret, user)');
  const {
    username,
    password
  } = user;
  if (!(username && password)) throw new Error('Missing required user credentials (username, password)');
  const scope = (options.scopes || []).join(' ');
  const scopeStr = scope ? `&scope=${scope}` : '';
  const basicAuth = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
  /**
   * This is mostly useful for internal testing purposes to be able to check
   * other oauth endpoints.
   */
  const oauthUri = options.oauthUri || `/oauth/${pKey}/customers/token`;
  const url = options.host.replace(/\/$/, '') + oauthUri;
  // encode username and password as requested by the system
  const body = `grant_type=password&username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}${scopeStr}`;
  return {
    basicAuth,
    url,
    body
  };
}
function buildRequestForRefreshTokenFlow(options) {
  if (!options) throw new Error('Missing required options');
  if (!options.host) throw new Error('Missing required option (host)');
  if (!options.projectKey) throw new Error('Missing required option (projectKey)');
  if (!options.credentials) throw new Error('Missing required option (credentials)');
  if (!options.refreshToken) throw new Error('Missing required option (refreshToken)');
  const {
    clientId,
    clientSecret
  } = options.credentials;
  if (!(clientId && clientSecret)) throw new Error('Missing required credentials (clientId, clientSecret)');
  const basicAuth = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.from(`${clientId}:${clientSecret}`).toString('base64');
  // This is mostly useful for internal testing purposes to be able to check
  // other oauth endpoints.
  const oauthUri = options.oauthUri || '/oauth/token';
  const url = options.host.replace(/\/$/, '') + oauthUri;
  const body = `grant_type=refresh_token&refresh_token=${encodeURIComponent(options.refreshToken)}`;
  return {
    basicAuth,
    url,
    body
  };
}
function buildRequestForAnonymousSessionFlow(options) {
  if (!options) throw new Error('Missing required options');
  if (!options.projectKey) throw new Error('Missing required option (projectKey)');
  const pKey = options.projectKey;
  options.oauthUri = options.oauthUri || `/oauth/${pKey}/anonymous/token`;
  const result = buildRequestForClientCredentialsFlow(options);
  if (options.credentials.anonymousId) result.body += `&anonymous_id=${options.credentials.anonymousId}`;
  return {
    ...result
  };
}

function mergeAuthHeader(token, req) {
  return {
    ...req,
    headers: {
      ...req.headers,
      Authorization: `Bearer ${token}`
    }
  };
}
function calculateExpirationTime(expiresIn) {
  return Date.now() +
  // Add a gap of 5 minutes before expiration time.
  expiresIn * 1000 - 5 * 60 * 1000;
}
async function executeRequest({
  fetcher,
  url,
  basicAuth,
  body,
  tokenCache,
  requestState,
  pendingTasks,
  response,
  tokenCacheKey
}) {
  try {
    const _res = await fetcher(url, {
      method: 'POST',
      headers: {
        Authorization: `Basic ${basicAuth}`,
        'Content-Length': buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.byteLength(body).toString(),
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body
    });
    if (_res.ok) {
      const {
        access_token: token,
        expires_in: expiresIn,
        refresh_token: refreshToken
      } = await _res.json();
      const expirationTime = calculateExpirationTime(expiresIn);

      // cache new generated token
      tokenCache.set({
        token,
        expirationTime,
        refreshToken
      }, tokenCacheKey);

      // Dispatch all pending requests
      requestState.set(false);

      /**
       * Freeze and copy pending queue, reset original one for accepting
       * new pending tasks
       */
      const executionQueue = pendingTasks.slice();
      pendingTasks = [];
      executionQueue.forEach(task => {
        // Assign the new token in the request header
        const requestWithAuth = mergeAuthHeader(token, task.request);
        /**
         * console.log('test', cache, pendingTasks)
         * Continue by calling the task's own next function
         */
        task.next(requestWithAuth, task.response);
      });
      return;
    }

    // Handle error response
    let parsed;
    const text = await _res.text();
    try {
      parsed = JSON.parse(text);
    } catch (error) {
      /* noop */
    }
    const error = new Error(parsed ? parsed.message : text);
    if (parsed) error.body = parsed;

    /**
     * to notify that token is either fetched or failed
     * in the below case token failed to be fetched
     * and reset requestState to false
     * so requestState could be shared between multi authMiddlewareBase functions
     */
    requestState.set(false);
    response.reject(error);
  } catch (error) {
    /**
     * to notify that token is either fetched or failed
     * in the below case token failed to be fetched
     * and reset requestState to false
     * so requestState could be shared between multi authMiddlewareBase functions
     */
    requestState.set(false);
    if (response && typeof response.reject === 'function') response.reject(error);
  }
}
function authMiddlewareBase({
  request,
  response,
  url,
  basicAuth,
  body,
  pendingTasks,
  requestState,
  tokenCache,
  tokenCacheKey,
  fetch: fetcher
}, next, userOptions) {
  if (!fetcher && typeof fetch === 'undefined') throw new Error('`fetch` is not available. Please pass in `fetch` as an option or have it globally available.');
  if (!fetcher) fetcher = fetch;
  // Check if there is already a `Authorization` header in the request.
  // If so, then go directly to the next middleware.
  if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
    next(request, response);
    return;
  }
  // If there was a token in the tokenCache, and it's not expired, append
  // the token in the `Authorization` header.
  const tokenObj = tokenCache.get(tokenCacheKey);
  if (tokenObj && tokenObj.token && Date.now() < tokenObj.expirationTime) {
    const requestWithAuth = mergeAuthHeader(tokenObj.token, request);
    next(requestWithAuth, response);
    return;
  }

  /**
   * Keep pending tasks until a token is fetched
   * Save next function as well, to call it once the token has been fetched, which prevents
   * unexpected behaviour in a context in which the next function uses global vars
   * or Promises to capture the token to hand it to other libraries, e.g. Apollo
   */
  pendingTasks.push({
    request,
    response,
    next
  });

  // If a token is currently being fetched, just wait ;)
  if (requestState.get()) return;

  // Mark that a token is being fetched
  requestState.set(true);

  /**
   * If there was a refreshToken in the tokenCache, and there was an expired
   * token or no token in the tokenCache, use the refreshToken flow
   */
  if (tokenObj && tokenObj.refreshToken && (!tokenObj.token || tokenObj.token && Date.now() > tokenObj.expirationTime)) {
    if (!userOptions) throw new Error('Missing required options');
    executeRequest({
      fetcher,
      ...buildRequestForRefreshTokenFlow({
        ...userOptions,
        refreshToken: tokenObj.refreshToken
      }),
      tokenCacheKey,
      tokenCache,
      requestState,
      pendingTasks,
      response
    });
    return;
  }

  // Token and refreshToken are not present or invalid. Request a new token...
  executeRequest({
    fetcher,
    url,
    basicAuth,
    body,
    tokenCacheKey,
    tokenCache,
    requestState,
    pendingTasks,
    response
  });
}

function store(initVal) {
  let value = initVal;
  return {
    get: TokenCacheOption => value,
    set: (val, TokenCacheOption) => {
      value = val;
    }
  };
}

function createAuthMiddlewareForAnonymousSessionFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: '',
    expirationTime: -1
  });
  const pendingTasks = [];
  const requestState = store(false);
  return next => (request, response) => {
    // Check if there is already a `Authorization` header in the request.
    // If so, then go directly to the next middleware.
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForAnonymousSessionFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      fetch: options.fetch
    };
    authMiddlewareBase(params, next, options);
  };
}

function buildTokenCacheKey(options) {
  return {
    clientId: options.credentials.clientId,
    host: options.host,
    projectKey: options.projectKey
  };
}

function createAuthMiddlewareForClientCredentialsFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: '',
    expirationTime: -1
  });
  const requestState = store(false);
  const pendingTasks = [];
  return next => (request, response) => {
    // Check if there is already a `Authorization` header in the request.
    // If so, then go directly to the next middleware.
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForClientCredentialsFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      tokenCacheKey: buildTokenCacheKey(options),
      fetch: options.fetch
    };
    authMiddlewareBase(params, next);
  };
}

function createAuthMiddlewareWithExistingToken$1(authorization = '', options = {}) {
  return next => (request, response) => {
    if (typeof authorization !== 'string') throw new Error('authorization must be a string');
    const force = options.force === undefined ? true : options.force;

    /** The request will not be modified if:
     *  1. no argument is passed
     *  2. force is false and authorization header exists
     */
    if (!authorization || (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) && force === false) {
      return next(request, response);
    }
    const requestWithAuth = {
      ...request,
      headers: {
        ...request.headers,
        Authorization: authorization
      }
    };
    return next(requestWithAuth, response);
  };
}

function createAuthMiddlewareForPasswordFlow$1(options) {
  const tokenCache = options.tokenCache || store({});
  const pendingTasks = [];
  const requestState = store(false);
  return next => (request, response) => {
    // Check if there is already a `Authorization` header in the request.
    // If so, then go directly to the next middleware.
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForPasswordFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      fetch: options.fetch
    };
    authMiddlewareBase(params, next, options);
  };
}

function createAuthMiddlewareForRefreshTokenFlow$1(options) {
  const tokenCache = options.tokenCache || store({
    token: '',
    expirationTime: -1
  });
  const pendingTasks = [];
  const requestState = store(false);
  return next => (request, response) => {
    // Check if there is already a `Authorization` header in the request.
    // If so, then go directly to the next middleware.
    if (request.headers && request.headers.authorization || request.headers && request.headers.Authorization) {
      next(request, response);
      return;
    }
    const params = {
      request,
      response,
      ...buildRequestForRefreshTokenFlow(options),
      pendingTasks,
      requestState,
      tokenCache,
      fetch: options.fetch
    };
    authMiddlewareBase(params, next);
  };
}

var authMiddlewares = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createAuthMiddlewareForAnonymousSessionFlow: createAuthMiddlewareForAnonymousSessionFlow$1,
  createAuthMiddlewareForClientCredentialsFlow: createAuthMiddlewareForClientCredentialsFlow$1,
  createAuthMiddlewareWithExistingToken: createAuthMiddlewareWithExistingToken$1,
  createAuthMiddlewareForPasswordFlow: createAuthMiddlewareForPasswordFlow$1,
  createAuthMiddlewareForRefreshTokenFlow: createAuthMiddlewareForRefreshTokenFlow$1
});

function createCorrelationIdMiddleware(options) {
  return next => (request, response) => {
    const nextRequest = {
      ...request,
      headers: {
        ...request.headers,
        'X-Correlation-ID': options.generate()
      }
    };
    next(nextRequest, response);
  };
}

function defineError(statusCode, message, meta = {}) {
  this.status = this.statusCode = this.code = statusCode;
  this.message = message;
  Object.assign(this, meta);
  this.name = this.constructor.name;
  this.constructor.prototype.__proto__ = Error.prototype;
  if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
}
function NetworkError(...args) {
  defineError.call(this, 0 /* special code to indicate network errors */, ...args);
}
function HttpError(...args) {
  defineError.call(this, /* code will be passed as arg */...args);
}
function BadRequest(...args) {
  defineError.call(this, 400, ...args);
}
function Unauthorized(...args) {
  defineError.call(this, 401, ...args);
}
function Forbidden(...args) {
  defineError.call(this, 403, ...args);
}
function NotFound(...args) {
  defineError.call(this, 404, ...args);
}
function ConcurrentModification(...args) {
  defineError.call(this, 409, ...args);
}
function InternalServerError(...args) {
  defineError.call(this, 500, ...args);
}
function ServiceUnavailable(...args) {
  defineError.call(this, 503, ...args);
}
function getErrorByCode(code) {
  switch (code) {
    case 0:
      return NetworkError;
    case 400:
      return BadRequest;
    case 401:
      return Unauthorized;
    case 403:
      return Forbidden;
    case 404:
      return NotFound;
    case 409:
      return ConcurrentModification;
    case 500:
      return InternalServerError;
    case 503:
      return ServiceUnavailable;
    default:
      return undefined;
  }
}

function parseHeaders(headers) {
  if (headers.raw)
    // node-fetch
    return headers.raw();

  // Tmp fix for Firefox until it supports iterables
  if (!headers.forEach) return {};

  // whatwg-fetch
  const map = {};
  headers.forEach((value, name) => {
    map[name] = value;
  });
  return map;
}

// performs a proper buffer check
function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}
function createError({
  statusCode,
  message,
  ...rest
}) {
  let errorMessage = message || 'Unexpected non-JSON error response';
  if (statusCode === 404) {
    errorMessage = `URI not found: ${rest.originalRequest?.uri || rest.uri}`;
    delete rest.uri; // remove the `uri` property from the response
  }
  const ResponseError = getErrorByCode(statusCode);
  if (ResponseError) return new ResponseError(errorMessage, rest);
  return new HttpError(statusCode, errorMessage, rest);
}

// calculates the delay duration exponentially
// More info about the algorithm use here https://goo.gl/Xk8h5f
function calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay) {
  if (backoff) return retryCount !== 0 // do not increase if it's the first retry
  ? Math.min(Math.round((Math.random() + 1) * retryDelay * 2 ** retryCount), maxDelay) : retryDelay;
  return retryDelay;
}
function maskAuthData(request, maskSensitiveHeaderData) {
  if (maskSensitiveHeaderData) {
    if (request && request.headers && request.headers.authorization) request.headers.authorization = 'Bearer ********';
    if (request && request.headers && request.headers.Authorization) request.headers.Authorization = 'Bearer ********';
  }
}
function createHttpMiddleware({
  host,
  credentialsMode,
  includeResponseHeaders,
  includeOriginalRequest,
  includeRequestInErrorResponse = true,
  maskSensitiveHeaderData = true,
  headersWithStringBody = [],
  enableRetry,
  timeout,
  retryConfig: {
    // encourage exponential backoff to prevent spamming the server if down
    maxRetries = 10,
    backoff = true,
    retryDelay = 200,
    maxDelay = Infinity,
    // If set to true reinitialize the abort controller when the timeout is reached and apply the retry config
    retryOnAbort = false,
    retryCodes = [503]
  } = {},
  fetch: fetcher,
  getAbortController
}) {
  //nodejs v18 has the fetch available and not the version 16
  if (!fetcher) throw new Error('`fetch` is not available. Please pass in `fetch` as an option or have it globally available.');
  if (timeout && !getAbortController) throw new Error('`AbortController` is not available. Please pass in `getAbortController` as an option or have AbortController globally available when using timeout.');
  let fetchFunction;
  if (fetcher) {
    fetchFunction = fetcher;
  } else {
    // `fetcher` is set here rather than the destructuring to ensure fetch is
    // declared before referencing it otherwise it would cause a `ReferenceError`.
    // For reference of this pattern: https://github.com/apollographql/apollo-link/blob/498b413a5b5199b0758ce898b3bb55451f57a2fa/packages/apollo-link-http/src/httpLink.ts#L49
    fetchFunction = fetch;
  }
  if (!Array.isArray(retryCodes)) {
    throw new Error('`retryCodes` option must be an array of retry status (error) codes.');
  }
  if (!Array.isArray(headersWithStringBody)) {
    throw new Error('`headersWithStringBody` option must be an array of strings');
  }
  return next => (request, response) => {
    const url = host.replace(/\/$/, '') + request.uri;
    const requestHeader = {
      ...request.headers
    };

    // If no content-type is provided, defaults to application/json
    if (!(Object.prototype.hasOwnProperty.call(requestHeader, 'Content-Type') || Object.prototype.hasOwnProperty.call(requestHeader, 'content-type'))) {
      requestHeader['Content-Type'] = 'application/json';
    }

    // Unset the content-type header if explicitly asked to (passing `null` as value).
    if (requestHeader['Content-Type'] === null) {
      delete requestHeader['Content-Type'];
    }

    // Ensure body is a string if content type is application/json or application/graphql
    const body = ['application/json', 'application/graphql', ...headersWithStringBody].indexOf(requestHeader['Content-Type']) > -1 && typeof request.body === 'string' || isBuffer(request.body) ? request.body : JSON.stringify(request.body || undefined);
    if (body && (typeof body === 'string' || isBuffer(body))) {
      requestHeader['Content-Length'] = buffer___WEBPACK_IMPORTED_MODULE_1__.Buffer.byteLength(body).toString();
    }
    const fetchOptions = {
      method: request.method,
      headers: requestHeader
    };
    if (credentialsMode) {
      fetchOptions.credentialsMode = credentialsMode;
    }
    if (body) {
      fetchOptions.body = body;
    }
    let retryCount = 0;
    // wrap in a fn so we can retry if error occur
    function executeFetch() {
      // Kick off timer for abortController directly before fetch.
      let timer;
      let abortController;
      if (timeout) {
        // Initialize the abort controller in case we do a retry on an aborted request to rest the signal
        abortController = (getAbortController ? getAbortController() : null) || new AbortController();
        fetchOptions.signal = abortController.signal;
        // Set the timer
        timer = setTimeout(() => {
          abortController.abort();
        }, timeout);
      }
      fetchFunction(url, fetchOptions).then(res => {
        if (res.ok) {
          if (fetchOptions.method === 'HEAD') {
            next(request, {
              ...response,
              statusCode: res.status
            });
            return;
          }
          res.text().then(result => {
            // Try to parse the response as JSON
            let parsed;
            try {
              parsed = result.length > 0 ? JSON.parse(result) : {};
            } catch (err) {
              if (enableRetry && retryCount < maxRetries) {
                setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
                retryCount += 1;
                return;
              }
              parsed = result;
            }
            const parsedResponse = {
              ...response,
              body: parsed,
              statusCode: res.status
            };
            if (includeResponseHeaders) parsedResponse.headers = parseHeaders(res.headers);
            if (includeOriginalRequest) {
              parsedResponse.request = {
                ...fetchOptions
              };
              maskAuthData(parsedResponse.request, maskSensitiveHeaderData);
            }
            next(request, parsedResponse);
          }).catch(err => {
            if (enableRetry && retryCount < maxRetries) {
              setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
              retryCount += 1;
              return;
            }
            const error = new NetworkError(err.message, {
              ...(includeRequestInErrorResponse ? {
                originalRequest: request
              } : {}),
              retryCount
            });
            maskAuthData(error.originalRequest, maskSensitiveHeaderData);
            next(request, {
              ...response,
              error,
              statusCode: 0
            });
          });
          return;
        }

        // Server responded with an error. Try to parse it as JSON, then
        // return a proper error type with all necessary meta information.
        res.text().then(text => {
          // Try to parse the error response as JSON
          let parsed;
          try {
            parsed = JSON.parse(text);
          } catch (error) {
            parsed = text;
          }
          const error = createError({
            statusCode: res.status,
            ...(includeRequestInErrorResponse ? {
              originalRequest: request
            } : res.status === 404 ? {
              uri: request.uri
            } : {}),
            retryCount,
            headers: parseHeaders(res.headers),
            ...(typeof parsed === 'object' ? {
              message: parsed.message,
              body: parsed
            } : {
              message: parsed,
              body: parsed
            })
          });
          if (enableRetry && (retryCodes.indexOf(error.statusCode) !== -1 || retryCodes?.indexOf(error.message) !== -1)) {
            if (retryCount < maxRetries) {
              setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
              retryCount += 1;
              return;
            }
          }
          maskAuthData(error.originalRequest, maskSensitiveHeaderData);
          // Let the final resolver to reject the promise
          const parsedResponse = {
            ...response,
            error,
            statusCode: res.status
          };
          next(request, parsedResponse);
        });
      },
      // We know that this is a "network" error thrown by the `fetch` library
      e => {
        // Retry when enabled and either the request was not aborted or retryOnAbort is enabled
        if (enableRetry && (retryOnAbort || !abortController || !abortController.signal)) {
          if (retryCount < maxRetries) {
            setTimeout(executeFetch, calcDelayDuration(retryCount, retryDelay, maxRetries, backoff, maxDelay));
            retryCount += 1;
            return;
          }
        }
        const error = new NetworkError(e.message, {
          ...(includeRequestInErrorResponse ? {
            originalRequest: request
          } : {}),
          retryCount
        });
        maskAuthData(error.originalRequest, maskSensitiveHeaderData);
        next(request, {
          ...response,
          error,
          statusCode: 0
        });
      }).finally(() => {
        clearTimeout(timer);
      });
    }
    executeFetch();
  };
}

function createLoggerMiddleware() {
  return next => (request, response) => {
    const {
      error,
      body,
      statusCode
    } = response;
    console.log('Request: ', request);
    console.log('Response: ', {
      error,
      body,
      statusCode
    });
    next(request, response);
  };
}

function createQueueMiddleware({
  concurrency = 20
}) {
  const queue = [];
  let runningCount = 0;
  const dequeue = next => {
    // We assume here that this task has been completed
    runningCount -= 1;

    // Check if there are any other pending tasks and execute them
    if (queue.length && runningCount <= concurrency) {
      const nextTask = queue.shift();
      runningCount += 1;
      next(nextTask.request, nextTask.response);
    }
  };
  return next => (request, response) => {
    // Override response `resolve` and `reject` to know when the request has
    // been completed and therefore trigger a pending task in the queue.
    const patchedResponse = {
      ...response,
      resolve(data) {
        // Resolve original promise
        response.resolve(data);
        dequeue(next);
      },
      reject(error) {
        // Reject original promise
        response.reject(error);
        dequeue(next);
      }
    };

    // Add task to the queue
    queue.push({
      request,
      response: patchedResponse
    });

    // If possible, run the task straight away
    if (runningCount < concurrency) {
      const nextTask = queue.shift();
      runningCount += 1;
      next(nextTask.request, nextTask.response);
    }
  };
}

var packageJson = {
	name: "@commercetools/sdk-client-v2",
	version: "2.5.0",
	engines: {
		node: ">=14"
	},
	description: "commercetools Composable Commerce TypeScript SDK client.",
	keywords: [
		"commercetools",
		"composable commerce",
		"sdk",
		"typescript",
		"client",
		"middleware",
		"http",
		"oauth",
		"auth"
	],
	homepage: "https://github.com/commercetools/commercetools-sdk-typescript",
	license: "MIT",
	directories: {
		lib: "lib",
		test: "test"
	},
	publishConfig: {
		access: "public"
	},
	repository: {
		type: "git",
		url: "git+https://github.com/commercetools/commercetools-sdk-typescript.git"
	},
	bugs: {
		url: "https://github.com/commercetools/commercetools-sdk-typescript/issues"
	},
	dependencies: {
		buffer: "^6.0.3",
		"node-fetch": "^2.6.1"
	},
	files: [
		"dist",
		"CHANGELOG.md"
	],
	author: "Chukwuemeka Ajima <meeky.ae@gmail.com>",
	main: "dist/commercetools-sdk-client-v2.cjs.js",
	module: "dist/commercetools-sdk-client-v2.esm.js",
	browser: {
		"./dist/commercetools-sdk-client-v2.cjs.js": "./dist/commercetools-sdk-client-v2.browser.cjs.js",
		"./dist/commercetools-sdk-client-v2.esm.js": "./dist/commercetools-sdk-client-v2.browser.esm.js"
	},
	devDependencies: {
		"abort-controller": "3.0.0",
		"common-tags": "1.8.2",
		dotenv: "16.4.5",
		jest: "29.7.0",
		nock: "12.0.3",
		"organize-imports-cli": "0.10.0"
	},
	scripts: {
		organize_imports: "find src -type f -name '*.ts' | xargs organize-imports-cli",
		postbuild: "yarn organize_imports",
		post_process_generate: "yarn organize_imports"
	}
};

/*
  This is the easiest way, for this use case, to detect if we're running in
  Node.js or in a browser environment. In other cases, this won't be even a
  problem as Rollup will provide the correct polyfill in the bundle.
  The main advantage by doing it this way is that it allows to easily test
  the code running in both environments, by overriding `global.window` in
  the specific test.
*/
const isBrowser = () => window.document && window.document.nodeType === 9;
function getSystemInfo() {
  if (isBrowser()) return window.navigator.userAgent;
  const nodeVersion = process?.version.slice(1) || '12'; // temporary fix for rn environment
  // const platformInfo = `(${process.platform}; ${process.arch})`
  // return `Node.js/${nodeVersion} ${platformInfo}`

  return `node.js/${nodeVersion}`;
}
function createUserAgent(options) {
  if (!options || Object.keys(options).length === 0 || !{}.hasOwnProperty.call(options, 'name')) throw new Error('Missing required option `name`');

  // Main info
  const baseInfo = options.version ? `${options.name}/${options.version}` : options.name;

  // Library info
  let libraryInfo = null;
  if (options.libraryName && !options.libraryVersion) libraryInfo = options.libraryName;else if (options.libraryName && options.libraryVersion) libraryInfo = `${options.libraryName}/${options.libraryVersion}`;

  // Contact info
  let contactInfo = null;
  if (options.contactUrl && !options.contactEmail) contactInfo = `(+${options.contactUrl})`;else if (!options.contactUrl && options.contactEmail) contactInfo = `(+${options.contactEmail})`;else if (options.contactUrl && options.contactEmail) contactInfo = `(+${options.contactUrl}; +${options.contactEmail})`;

  // System info
  const systemInfo = getSystemInfo();

  // customName
  const customAgent = options.customAgent || '';
  return [baseInfo, systemInfo, libraryInfo, contactInfo, customAgent].filter(Boolean).join(' ');
}

function createUserAgentMiddleware(options) {
  const userAgent = createUserAgent({
    ...options,
    name: `commercetools-sdk-javascript-v2/${packageJson.version}`
  });
  return next => (request, response) => {
    const requestWithUserAgent = {
      ...request,
      headers: {
        ...request.headers,
        'User-Agent': userAgent
      }
    };
    next(requestWithUserAgent, response);
  };
}

const {
  createAuthMiddlewareForPasswordFlow,
  createAuthMiddlewareForAnonymousSessionFlow,
  createAuthMiddlewareForClientCredentialsFlow,
  createAuthMiddlewareForRefreshTokenFlow,
  createAuthMiddlewareWithExistingToken
} = authMiddlewares;
class ClientBuilder {
  constructor() {
    _defineProperty(this, "projectKey", void 0);
    _defineProperty(this, "authMiddleware", void 0);
    _defineProperty(this, "httpMiddleware", void 0);
    _defineProperty(this, "userAgentMiddleware", void 0);
    _defineProperty(this, "correlationIdMiddleware", void 0);
    _defineProperty(this, "loggerMiddleware", void 0);
    _defineProperty(this, "queueMiddleware", void 0);
    _defineProperty(this, "telemetryMiddleware", void 0);
    _defineProperty(this, "beforeMiddleware", void 0);
    _defineProperty(this, "afterMiddleware", void 0);
    _defineProperty(this, "middlewares", []);
  }
  withProjectKey(key) {
    this.projectKey = key;
    return this;
  }
  defaultClient(baseUri, credentials, oauthUri, projectKey) {
    return this.withClientCredentialsFlow({
      host: oauthUri,
      projectKey: projectKey || this.projectKey,
      credentials
    }).withHttpMiddleware({
      host: baseUri,
      fetch: (node_fetch__WEBPACK_IMPORTED_MODULE_0___default())
    }).withLoggerMiddleware().withUserAgentMiddleware();
  }
  withAuthMiddleware(authMiddleware) {
    this.authMiddleware = authMiddleware;
    return this;
  }
  withMiddleware(middleware) {
    this.middlewares.push(middleware);
    return this;
  }
  withClientCredentialsFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForClientCredentialsFlow({
      host: options.host || 'https://auth.europe-west1.gcp.commercetools.com',
      projectKey: options.projectKey || this.projectKey,
      credentials: {
        clientId: options.credentials.clientId || '',
        clientSecret: options.credentials.clientSecret || ''
      },
      oauthUri: options.oauthUri || '',
      scopes: options.scopes,
      fetch: options.fetch || (node_fetch__WEBPACK_IMPORTED_MODULE_0___default()),
      ...options
    }));
  }
  withPasswordFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForPasswordFlow({
      host: options.host || 'https://auth.europe-west1.gcp.commercetools.com',
      projectKey: options.projectKey || this.projectKey,
      credentials: {
        clientId: options.credentials.clientId || '',
        clientSecret: options.credentials.clientSecret || '',
        user: {
          username: options.credentials.user.username || '',
          password: options.credentials.user.password || ''
        }
      },
      fetch: options.fetch || (node_fetch__WEBPACK_IMPORTED_MODULE_0___default()),
      ...options
    }));
  }
  withAnonymousSessionFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForAnonymousSessionFlow({
      host: options.host || 'https://auth.europe-west1.gcp.commercetools.com',
      projectKey: this.projectKey || options.projectKey,
      credentials: {
        clientId: options.credentials.clientId || '',
        clientSecret: options.credentials.clientSecret || '',
        anonymousId: options.credentials.anonymousId || ''
      },
      fetch: options.fetch || (node_fetch__WEBPACK_IMPORTED_MODULE_0___default()),
      ...options
    }));
  }
  withRefreshTokenFlow(options) {
    return this.withAuthMiddleware(createAuthMiddlewareForRefreshTokenFlow({
      host: options.host || 'https://auth.europe-west1.gcp.commercetools.com',
      projectKey: this.projectKey || options.projectKey,
      credentials: {
        clientId: options.credentials.clientId || '',
        clientSecret: options.credentials.clientSecret || ''
      },
      fetch: options.fetch || (node_fetch__WEBPACK_IMPORTED_MODULE_0___default()),
      refreshToken: options.refreshToken || '',
      ...options
    }));
  }
  withExistingTokenFlow(authorization, options) {
    return this.withAuthMiddleware(createAuthMiddlewareWithExistingToken(authorization, {
      force: options.force || true,
      ...options
    }));
  }
  withHttpMiddleware(options) {
    this.httpMiddleware = createHttpMiddleware({
      host: options.host || 'https://api.europe-west1.gcp.commercetools.com',
      fetch: options.fetch || (node_fetch__WEBPACK_IMPORTED_MODULE_0___default()),
      ...options
    });
    return this;
  }
  withUserAgentMiddleware(options) {
    this.userAgentMiddleware = createUserAgentMiddleware(options);
    return this;
  }
  withQueueMiddleware(options) {
    this.queueMiddleware = createQueueMiddleware({
      concurrency: options.concurrency || 20,
      ...options
    });
    return this;
  }
  withLoggerMiddleware(options) {
    const {
      logger,
      ...rest
    } = options || {};
    this.loggerMiddleware = typeof options?.logger == 'function' && options.logger(rest) || createLoggerMiddleware();
    return this;
  }
  withCorrelationIdMiddleware(options) {
    this.correlationIdMiddleware = createCorrelationIdMiddleware({
      generate: options.generate || null,
      ...options
    });
    return this;
  }
  withTelemetryMiddleware(options) {
    const {
      createTelemetryMiddleware,
      ...rest
    } = options;
    this.withUserAgentMiddleware({
      customAgent: rest?.userAgent || 'typescript-sdk-apm-middleware'
    });
    this.telemetryMiddleware = createTelemetryMiddleware(rest);
    return this;
  }
  withBeforeExecutionMiddleware(options) {
    const {
      middleware,
      ...rest
    } = options || {};
    this.beforeMiddleware = options.middleware(rest);
    return this;
  }
  withAfterExecutionMiddleware(options) {
    const {
      middleware,
      ...rest
    } = options || {};
    this.afterMiddleware = options.middleware(rest);
    return this;
  }
  build() {
    const middlewares = this.middlewares.slice();
    if (this.telemetryMiddleware) middlewares.push(this.telemetryMiddleware);
    if (this.correlationIdMiddleware) middlewares.push(this.correlationIdMiddleware);
    if (this.userAgentMiddleware) middlewares.push(this.userAgentMiddleware);
    if (this.authMiddleware) middlewares.push(this.authMiddleware);
    if (this.beforeMiddleware) middlewares.push(this.beforeMiddleware);
    if (this.queueMiddleware) middlewares.push(this.queueMiddleware);
    if (this.httpMiddleware) middlewares.push(this.httpMiddleware);
    if (this.afterMiddleware) middlewares.push(this.afterMiddleware);
    if (this.loggerMiddleware) middlewares.push(this.loggerMiddleware);
    return createClient({
      middlewares
    });
  }
}




/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/iso-3166-1/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/iso-3166-1/dist/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.all = exports.whereNumeric = exports.whereAlpha3 = exports.whereAlpha2 = exports.whereCountry = void 0;
const iso_3166_1 = __importDefault(__webpack_require__(/*! ./iso-3166 */ "./node_modules/iso-3166-1/dist/iso-3166.js"));
/**
 * Get country by country name
 *
 * @param {string} name
 * @returns {Country | undefined}
 */
exports.whereCountry = (name) => {
    return iso_3166_1.default.find((country) => country.country.toUpperCase() === name.toUpperCase());
};
/**
 * Get country by ISO 3166-1 Alpha-2
 *
 * @param {string} alpha2
 * @returns {Country | undefined}
 */
exports.whereAlpha2 = (alpha2) => {
    return iso_3166_1.default.find((country) => country.alpha2 === alpha2.toUpperCase());
};
/**
 * Get country by ISO 3166-1 Alpha-3
 *
 * @param {string} alpha3
 * @returns {Country | undefined}
 */
exports.whereAlpha3 = (alpha3) => {
    return iso_3166_1.default.find((country) => country.alpha3 === alpha3.toUpperCase());
};
/**
 * Get country by ISO 3166-1 Numeric
 *
 * @param {string | number} numeric
 * @returns {Country | undefined}
 */
exports.whereNumeric = (numeric) => {
    return iso_3166_1.default.find((country) => country.numeric === String(numeric));
};
/**
 * Get all countries.
 *
 * @returns {Array<Country>}
 */
exports.all = () => iso_3166_1.default;
exports["default"] = {
    all: exports.all,
    whereCountry: exports.whereCountry,
    whereAlpha2: exports.whereAlpha2,
    whereAlpha3: exports.whereAlpha3,
    whereNumeric: exports.whereNumeric,
};


/***/ }),

/***/ "./node_modules/iso-3166-1/dist/iso-3166.js":
/*!**************************************************!*\
  !*** ./node_modules/iso-3166-1/dist/iso-3166.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const countries = [
    {
        country: 'Afghanistan',
        alpha2: 'AF',
        alpha3: 'AFG',
        numeric: '004',
    },
    {
        country: 'land Islands',
        alpha2: 'AX',
        alpha3: 'ALA',
        numeric: '248',
    },
    {
        country: 'Albania',
        alpha2: 'AL',
        alpha3: 'ALB',
        numeric: '008',
    },
    {
        country: 'Algeria',
        alpha2: 'DZ',
        alpha3: 'DZA',
        numeric: '012',
    },
    {
        country: 'American Samoa',
        alpha2: 'AS',
        alpha3: 'ASM',
        numeric: '016',
    },
    {
        country: 'Andorra',
        alpha2: 'AD',
        alpha3: 'AND',
        numeric: '020',
    },
    {
        country: 'Angola',
        alpha2: 'AO',
        alpha3: 'AGO',
        numeric: '024',
    },
    {
        country: 'Anguilla',
        alpha2: 'AI',
        alpha3: 'AIA',
        numeric: '660',
    },
    {
        country: 'Antarctica',
        alpha2: 'AQ',
        alpha3: 'ATA',
        numeric: '010',
    },
    {
        country: 'Antigua and Barbuda',
        alpha2: 'AG',
        alpha3: 'ATG',
        numeric: '028',
    },
    {
        country: 'Argentina',
        alpha2: 'AR',
        alpha3: 'ARG',
        numeric: '032',
    },
    {
        country: 'Armenia',
        alpha2: 'AM',
        alpha3: 'ARM',
        numeric: '051',
    },
    {
        country: 'Aruba',
        alpha2: 'AW',
        alpha3: 'ABW',
        numeric: '533',
    },
    {
        country: 'Australia',
        alpha2: 'AU',
        alpha3: 'AUS',
        numeric: '036',
    },
    {
        country: 'Austria',
        alpha2: 'AT',
        alpha3: 'AUT',
        numeric: '040',
    },
    {
        country: 'Azerbaijan',
        alpha2: 'AZ',
        alpha3: 'AZE',
        numeric: '031',
    },
    {
        country: 'Bahamas',
        alpha2: 'BS',
        alpha3: 'BHS',
        numeric: '044',
    },
    {
        country: 'Bahrain',
        alpha2: 'BH',
        alpha3: 'BHR',
        numeric: '048',
    },
    {
        country: 'Bangladesh',
        alpha2: 'BD',
        alpha3: 'BGD',
        numeric: '050',
    },
    {
        country: 'Barbados',
        alpha2: 'BB',
        alpha3: 'BRB',
        numeric: '052',
    },
    {
        country: 'Belarus',
        alpha2: 'BY',
        alpha3: 'BLR',
        numeric: '112',
    },
    {
        country: 'Belgium',
        alpha2: 'BE',
        alpha3: 'BEL',
        numeric: '056',
    },
    {
        country: 'Belize',
        alpha2: 'BZ',
        alpha3: 'BLZ',
        numeric: '084',
    },
    {
        country: 'Benin',
        alpha2: 'BJ',
        alpha3: 'BEN',
        numeric: '204',
    },
    {
        country: 'Bermuda',
        alpha2: 'BM',
        alpha3: 'BMU',
        numeric: '060',
    },
    {
        country: 'Bhutan',
        alpha2: 'BT',
        alpha3: 'BTN',
        numeric: '064',
    },
    {
        country: 'Bolivia',
        alpha2: 'BO',
        alpha3: 'BOL',
        numeric: '068',
    },
    {
        country: 'Bonaire, Sint Eustatius and Saba',
        alpha2: 'BQ',
        alpha3: 'BES',
        numeric: '535',
    },
    {
        country: 'Bosnia and Herzegovina',
        alpha2: 'BA',
        alpha3: 'BIH',
        numeric: '070',
    },
    {
        country: 'Botswana',
        alpha2: 'BW',
        alpha3: 'BWA',
        numeric: '072',
    },
    {
        country: 'Bouvet Island',
        alpha2: 'BV',
        alpha3: 'BVT',
        numeric: '074',
    },
    {
        country: 'Brazil',
        alpha2: 'BR',
        alpha3: 'BRA',
        numeric: '076',
    },
    {
        country: 'British Indian Ocean Territory',
        alpha2: 'IO',
        alpha3: 'IOT',
        numeric: '086',
    },
    {
        country: 'Brunei Darussalam',
        alpha2: 'BN',
        alpha3: 'BRN',
        numeric: '096',
    },
    {
        country: 'Bulgaria',
        alpha2: 'BG',
        alpha3: 'BGR',
        numeric: '100',
    },
    {
        country: 'Burkina Faso',
        alpha2: 'BF',
        alpha3: 'BFA',
        numeric: '854',
    },
    {
        country: 'Burundi',
        alpha2: 'BI',
        alpha3: 'BDI',
        numeric: '108',
    },
    {
        country: 'Cabo Verde',
        alpha2: 'CV',
        alpha3: 'CPV',
        numeric: '132',
    },
    {
        country: 'Cambodia',
        alpha2: 'KH',
        alpha3: 'KHM',
        numeric: '116',
    },
    {
        country: 'Cameroon',
        alpha2: 'CM',
        alpha3: 'CMR',
        numeric: '120',
    },
    {
        country: 'Canada',
        alpha2: 'CA',
        alpha3: 'CAN',
        numeric: '124',
    },
    {
        country: 'Cayman Islands',
        alpha2: 'KY',
        alpha3: 'CYM',
        numeric: '136',
    },
    {
        country: 'Central African Republic',
        alpha2: 'CF',
        alpha3: 'CAF',
        numeric: '140',
    },
    {
        country: 'Chad',
        alpha2: 'TD',
        alpha3: 'TCD',
        numeric: '148',
    },
    {
        country: 'Chile',
        alpha2: 'CL',
        alpha3: 'CHL',
        numeric: '152',
    },
    {
        country: 'China',
        alpha2: 'CN',
        alpha3: 'CHN',
        numeric: '156',
    },
    {
        country: 'Christmas Island',
        alpha2: 'CX',
        alpha3: 'CXR',
        numeric: '162',
    },
    {
        country: 'Cocos Islands',
        alpha2: 'CC',
        alpha3: 'CCK',
        numeric: '166',
    },
    {
        country: 'Colombia',
        alpha2: 'CO',
        alpha3: 'COL',
        numeric: '170',
    },
    {
        country: 'Comoros',
        alpha2: 'KM',
        alpha3: 'COM',
        numeric: '174',
    },
    {
        country: 'Congo',
        alpha2: 'CG',
        alpha3: 'COG',
        numeric: '178',
    },
    {
        country: 'Congo',
        alpha2: 'CD',
        alpha3: 'COD',
        numeric: '180',
    },
    {
        country: 'Cook Islands',
        alpha2: 'CK',
        alpha3: 'COK',
        numeric: '184',
    },
    {
        country: 'Costa Rica',
        alpha2: 'CR',
        alpha3: 'CRI',
        numeric: '188',
    },
    {
        country: "Cte d'Ivoire",
        alpha2: 'CI',
        alpha3: 'CIV',
        numeric: '384',
    },
    {
        country: 'Croatia',
        alpha2: 'HR',
        alpha3: 'HRV',
        numeric: '191',
    },
    {
        country: 'Cuba',
        alpha2: 'CU',
        alpha3: 'CUB',
        numeric: '192',
    },
    {
        country: 'Curaao',
        alpha2: 'CW',
        alpha3: 'CUW',
        numeric: '531',
    },
    {
        country: 'Cyprus',
        alpha2: 'CY',
        alpha3: 'CYP',
        numeric: '196',
    },
    {
        country: 'Czech Republic',
        alpha2: 'CZ',
        alpha3: 'CZE',
        numeric: '203',
    },
    {
        country: 'Denmark',
        alpha2: 'DK',
        alpha3: 'DNK',
        numeric: '208',
    },
    {
        country: 'Djibouti',
        alpha2: 'DJ',
        alpha3: 'DJI',
        numeric: '262',
    },
    {
        country: 'Dominica',
        alpha2: 'DM',
        alpha3: 'DMA',
        numeric: '212',
    },
    {
        country: 'Dominican Republic',
        alpha2: 'DO',
        alpha3: 'DOM',
        numeric: '214',
    },
    {
        country: 'Ecuador',
        alpha2: 'EC',
        alpha3: 'ECU',
        numeric: '218',
    },
    {
        country: 'Egypt',
        alpha2: 'EG',
        alpha3: 'EGY',
        numeric: '818',
    },
    {
        country: 'El Salvador',
        alpha2: 'SV',
        alpha3: 'SLV',
        numeric: '222',
    },
    {
        country: 'Equatorial Guinea',
        alpha2: 'GQ',
        alpha3: 'GNQ',
        numeric: '226',
    },
    {
        country: 'Eritrea',
        alpha2: 'ER',
        alpha3: 'ERI',
        numeric: '232',
    },
    {
        country: 'Estonia',
        alpha2: 'EE',
        alpha3: 'EST',
        numeric: '233',
    },
    {
        country: 'Ethiopia',
        alpha2: 'ET',
        alpha3: 'ETH',
        numeric: '231',
    },
    {
        country: 'Falkland Islands',
        alpha2: 'FK',
        alpha3: 'FLK',
        numeric: '238',
    },
    {
        country: 'Faroe Islands',
        alpha2: 'FO',
        alpha3: 'FRO',
        numeric: '234',
    },
    {
        country: 'Fiji',
        alpha2: 'FJ',
        alpha3: 'FJI',
        numeric: '242',
    },
    {
        country: 'Finland',
        alpha2: 'FI',
        alpha3: 'FIN',
        numeric: '246',
    },
    {
        country: 'France',
        alpha2: 'FR',
        alpha3: 'FRA',
        numeric: '250',
    },
    {
        country: 'French Guiana',
        alpha2: 'GF',
        alpha3: 'GUF',
        numeric: '254',
    },
    {
        country: 'French Polynesia',
        alpha2: 'PF',
        alpha3: 'PYF',
        numeric: '258',
    },
    {
        country: 'French Southern Territories',
        alpha2: 'TF',
        alpha3: 'ATF',
        numeric: '260',
    },
    {
        country: 'Gabon',
        alpha2: 'GA',
        alpha3: 'GAB',
        numeric: '266',
    },
    {
        country: 'Gambia',
        alpha2: 'GM',
        alpha3: 'GMB',
        numeric: '270',
    },
    {
        country: 'Georgia',
        alpha2: 'GE',
        alpha3: 'GEO',
        numeric: '268',
    },
    {
        country: 'Germany',
        alpha2: 'DE',
        alpha3: 'DEU',
        numeric: '276',
    },
    {
        country: 'Ghana',
        alpha2: 'GH',
        alpha3: 'GHA',
        numeric: '288',
    },
    {
        country: 'Gibraltar',
        alpha2: 'GI',
        alpha3: 'GIB',
        numeric: '292',
    },
    {
        country: 'Greece',
        alpha2: 'GR',
        alpha3: 'GRC',
        numeric: '300',
    },
    {
        country: 'Greenland',
        alpha2: 'GL',
        alpha3: 'GRL',
        numeric: '304',
    },
    {
        country: 'Grenada',
        alpha2: 'GD',
        alpha3: 'GRD',
        numeric: '308',
    },
    {
        country: 'Guadeloupe',
        alpha2: 'GP',
        alpha3: 'GLP',
        numeric: '312',
    },
    {
        country: 'Guam',
        alpha2: 'GU',
        alpha3: 'GUM',
        numeric: '316',
    },
    {
        country: 'Guatemala',
        alpha2: 'GT',
        alpha3: 'GTM',
        numeric: '320',
    },
    {
        country: 'Guernsey',
        alpha2: 'GG',
        alpha3: 'GGY',
        numeric: '831',
    },
    {
        country: 'Guinea',
        alpha2: 'GN',
        alpha3: 'GIN',
        numeric: '324',
    },
    {
        country: 'Guinea-Bissau',
        alpha2: 'GW',
        alpha3: 'GNB',
        numeric: '624',
    },
    {
        country: 'Guyana',
        alpha2: 'GY',
        alpha3: 'GUY',
        numeric: '328',
    },
    {
        country: 'Haiti',
        alpha2: 'HT',
        alpha3: 'HTI',
        numeric: '332',
    },
    {
        country: 'Heard Island and McDonald Islands',
        alpha2: 'HM',
        alpha3: 'HMD',
        numeric: '334',
    },
    {
        country: 'Holy See',
        alpha2: 'VA',
        alpha3: 'VAT',
        numeric: '336',
    },
    {
        country: 'Honduras',
        alpha2: 'HN',
        alpha3: 'HND',
        numeric: '340',
    },
    {
        country: 'Hong Kong',
        alpha2: 'HK',
        alpha3: 'HKG',
        numeric: '344',
    },
    {
        country: 'Hungary',
        alpha2: 'HU',
        alpha3: 'HUN',
        numeric: '348',
    },
    {
        country: 'Iceland',
        alpha2: 'IS',
        alpha3: 'ISL',
        numeric: '352',
    },
    {
        country: 'India',
        alpha2: 'IN',
        alpha3: 'IND',
        numeric: '356',
    },
    {
        country: 'Indonesia',
        alpha2: 'ID',
        alpha3: 'IDN',
        numeric: '360',
    },
    {
        country: 'Islamic Republic of Iran',
        alpha2: 'IR',
        alpha3: 'IRN',
        numeric: '364',
    },
    {
        country: 'Iraq',
        alpha2: 'IQ',
        alpha3: 'IRQ',
        numeric: '368',
    },
    {
        country: 'Ireland',
        alpha2: 'IE',
        alpha3: 'IRL',
        numeric: '372',
    },
    {
        country: 'Isle of Man',
        alpha2: 'IM',
        alpha3: 'IMN',
        numeric: '833',
    },
    {
        country: 'Israel',
        alpha2: 'IL',
        alpha3: 'ISR',
        numeric: '376',
    },
    {
        country: 'Italy',
        alpha2: 'IT',
        alpha3: 'ITA',
        numeric: '380',
    },
    {
        country: 'Jamaica',
        alpha2: 'JM',
        alpha3: 'JAM',
        numeric: '388',
    },
    {
        country: 'Japan',
        alpha2: 'JP',
        alpha3: 'JPN',
        numeric: '392',
    },
    {
        country: 'Jersey',
        alpha2: 'JE',
        alpha3: 'JEY',
        numeric: '832',
    },
    {
        country: 'Jordan',
        alpha2: 'JO',
        alpha3: 'JOR',
        numeric: '400',
    },
    {
        country: 'Kazakhstan',
        alpha2: 'KZ',
        alpha3: 'KAZ',
        numeric: '398',
    },
    {
        country: 'Kenya',
        alpha2: 'KE',
        alpha3: 'KEN',
        numeric: '404',
    },
    {
        country: 'Kiribati',
        alpha2: 'KI',
        alpha3: 'KIR',
        numeric: '296',
    },
    {
        country: "Democratic People's Republic of Korea",
        alpha2: 'KP',
        alpha3: 'PRK',
        numeric: '408',
    },
    {
        country: 'Republic of Korea',
        alpha2: 'KR',
        alpha3: 'KOR',
        numeric: '410',
    },
    {
        country: 'Kuwait',
        alpha2: 'KW',
        alpha3: 'KWT',
        numeric: '414',
    },
    {
        country: 'Kyrgyzstan',
        alpha2: 'KG',
        alpha3: 'KGZ',
        numeric: '417',
    },
    {
        country: "Lao People's Democratic Republic",
        alpha2: 'LA',
        alpha3: 'LAO',
        numeric: '418',
    },
    {
        country: 'Latvia',
        alpha2: 'LV',
        alpha3: 'LVA',
        numeric: '428',
    },
    {
        country: 'Lebanon',
        alpha2: 'LB',
        alpha3: 'LBN',
        numeric: '422',
    },
    {
        country: 'Lesotho',
        alpha2: 'LS',
        alpha3: 'LSO',
        numeric: '426',
    },
    {
        country: 'Liberia',
        alpha2: 'LR',
        alpha3: 'LBR',
        numeric: '430',
    },
    {
        country: 'Libya',
        alpha2: 'LY',
        alpha3: 'LBY',
        numeric: '434',
    },
    {
        country: 'Liechtenstein',
        alpha2: 'LI',
        alpha3: 'LIE',
        numeric: '438',
    },
    {
        country: 'Lithuania',
        alpha2: 'LT',
        alpha3: 'LTU',
        numeric: '440',
    },
    {
        country: 'Luxembourg',
        alpha2: 'LU',
        alpha3: 'LUX',
        numeric: '442',
    },
    {
        country: 'Macao',
        alpha2: 'MO',
        alpha3: 'MAC',
        numeric: '446',
    },
    {
        country: 'Macedonia',
        alpha2: 'MK',
        alpha3: 'MKD',
        numeric: '807',
    },
    {
        country: 'Madagascar',
        alpha2: 'MG',
        alpha3: 'MDG',
        numeric: '450',
    },
    {
        country: 'Malawi',
        alpha2: 'MW',
        alpha3: 'MWI',
        numeric: '454',
    },
    {
        country: 'Malaysia',
        alpha2: 'MY',
        alpha3: 'MYS',
        numeric: '458',
    },
    {
        country: 'Maldives',
        alpha2: 'MV',
        alpha3: 'MDV',
        numeric: '462',
    },
    {
        country: 'Mali',
        alpha2: 'ML',
        alpha3: 'MLI',
        numeric: '466',
    },
    {
        country: 'Malta',
        alpha2: 'MT',
        alpha3: 'MLT',
        numeric: '470',
    },
    {
        country: 'Marshall Islands',
        alpha2: 'MH',
        alpha3: 'MHL',
        numeric: '584',
    },
    {
        country: 'Martinique',
        alpha2: 'MQ',
        alpha3: 'MTQ',
        numeric: '474',
    },
    {
        country: 'Mauritania',
        alpha2: 'MR',
        alpha3: 'MRT',
        numeric: '478',
    },
    {
        country: 'Mauritius',
        alpha2: 'MU',
        alpha3: 'MUS',
        numeric: '480',
    },
    {
        country: 'Mayotte',
        alpha2: 'YT',
        alpha3: 'MYT',
        numeric: '175',
    },
    {
        country: 'Mexico',
        alpha2: 'MX',
        alpha3: 'MEX',
        numeric: '484',
    },
    {
        country: 'Federated States of Micronesia',
        alpha2: 'FM',
        alpha3: 'FSM',
        numeric: '583',
    },
    {
        country: 'Republic of Moldova',
        alpha2: 'MD',
        alpha3: 'MDA',
        numeric: '498',
    },
    {
        country: 'Monaco',
        alpha2: 'MC',
        alpha3: 'MCO',
        numeric: '492',
    },
    {
        country: 'Mongolia',
        alpha2: 'MN',
        alpha3: 'MNG',
        numeric: '496',
    },
    {
        country: 'Montenegro',
        alpha2: 'ME',
        alpha3: 'MNE',
        numeric: '499',
    },
    {
        country: 'Montserrat',
        alpha2: 'MS',
        alpha3: 'MSR',
        numeric: '500',
    },
    {
        country: 'Morocco',
        alpha2: 'MA',
        alpha3: 'MAR',
        numeric: '504',
    },
    {
        country: 'Mozambique',
        alpha2: 'MZ',
        alpha3: 'MOZ',
        numeric: '508',
    },
    {
        country: 'Myanmar',
        alpha2: 'MM',
        alpha3: 'MMR',
        numeric: '104',
    },
    {
        country: 'Namibia',
        alpha2: 'NA',
        alpha3: 'NAM',
        numeric: '516',
    },
    {
        country: 'Nauru',
        alpha2: 'NR',
        alpha3: 'NRU',
        numeric: '520',
    },
    {
        country: 'Nepal',
        alpha2: 'NP',
        alpha3: 'NPL',
        numeric: '524',
    },
    {
        country: 'Netherlands',
        alpha2: 'NL',
        alpha3: 'NLD',
        numeric: '528',
    },
    {
        country: 'New Caledonia',
        alpha2: 'NC',
        alpha3: 'NCL',
        numeric: '540',
    },
    {
        country: 'New Zealand',
        alpha2: 'NZ',
        alpha3: 'NZL',
        numeric: '554',
    },
    {
        country: 'Nicaragua',
        alpha2: 'NI',
        alpha3: 'NIC',
        numeric: '558',
    },
    {
        country: 'Niger',
        alpha2: 'NE',
        alpha3: 'NER',
        numeric: '562',
    },
    {
        country: 'Nigeria',
        alpha2: 'NG',
        alpha3: 'NGA',
        numeric: '566',
    },
    {
        country: 'Niue',
        alpha2: 'NU',
        alpha3: 'NIU',
        numeric: '570',
    },
    {
        country: 'Norfolk Island',
        alpha2: 'NF',
        alpha3: 'NFK',
        numeric: '574',
    },
    {
        country: 'Northern Mariana Islands',
        alpha2: 'MP',
        alpha3: 'MNP',
        numeric: '580',
    },
    {
        country: 'Norway',
        alpha2: 'NO',
        alpha3: 'NOR',
        numeric: '578',
    },
    {
        country: 'Oman',
        alpha2: 'OM',
        alpha3: 'OMN',
        numeric: '512',
    },
    {
        country: 'Pakistan',
        alpha2: 'PK',
        alpha3: 'PAK',
        numeric: '586',
    },
    {
        country: 'Palau',
        alpha2: 'PW',
        alpha3: 'PLW',
        numeric: '585',
    },
    {
        country: 'State of Palestine',
        alpha2: 'PS',
        alpha3: 'PSE',
        numeric: '275',
    },
    {
        country: 'Panama',
        alpha2: 'PA',
        alpha3: 'PAN',
        numeric: '591',
    },
    {
        country: 'Papua New Guinea',
        alpha2: 'PG',
        alpha3: 'PNG',
        numeric: '598',
    },
    {
        country: 'Paraguay',
        alpha2: 'PY',
        alpha3: 'PRY',
        numeric: '600',
    },
    {
        country: 'Peru',
        alpha2: 'PE',
        alpha3: 'PER',
        numeric: '604',
    },
    {
        country: 'Philippines',
        alpha2: 'PH',
        alpha3: 'PHL',
        numeric: '608',
    },
    {
        country: 'Pitcairn',
        alpha2: 'PN',
        alpha3: 'PCN',
        numeric: '612',
    },
    {
        country: 'Poland',
        alpha2: 'PL',
        alpha3: 'POL',
        numeric: '616',
    },
    {
        country: 'Portugal',
        alpha2: 'PT',
        alpha3: 'PRT',
        numeric: '620',
    },
    {
        country: 'Puerto Rico',
        alpha2: 'PR',
        alpha3: 'PRI',
        numeric: '630',
    },
    {
        country: 'Qatar',
        alpha2: 'QA',
        alpha3: 'QAT',
        numeric: '634',
    },
    {
        country: 'Runion',
        alpha2: 'RE',
        alpha3: 'REU',
        numeric: '638',
    },
    {
        country: 'Romania',
        alpha2: 'RO',
        alpha3: 'ROU',
        numeric: '642',
    },
    {
        country: 'Russian Federation',
        alpha2: 'RU',
        alpha3: 'RUS',
        numeric: '643',
    },
    {
        country: 'Rwanda',
        alpha2: 'RW',
        alpha3: 'RWA',
        numeric: '646',
    },
    {
        country: 'Saint Barthlemy',
        alpha2: 'BL',
        alpha3: 'BLM',
        numeric: '652',
    },
    {
        country: 'Saint Helena, Ascension and Tristan da Cunha',
        alpha2: 'SH',
        alpha3: 'SHN',
        numeric: '654',
    },
    {
        country: 'Saint Kitts and Nevis',
        alpha2: 'KN',
        alpha3: 'KNA',
        numeric: '659',
    },
    {
        country: 'Saint Lucia',
        alpha2: 'LC',
        alpha3: 'LCA',
        numeric: '662',
    },
    {
        country: 'Saint Martin',
        alpha2: 'MF',
        alpha3: 'MAF',
        numeric: '663',
    },
    {
        country: 'Saint Pierre and Miquelon',
        alpha2: 'PM',
        alpha3: 'SPM',
        numeric: '666',
    },
    {
        country: 'Saint Vincent and the Grenadines',
        alpha2: 'VC',
        alpha3: 'VCT',
        numeric: '670',
    },
    {
        country: 'Samoa',
        alpha2: 'WS',
        alpha3: 'WSM',
        numeric: '882',
    },
    {
        country: 'San Marino',
        alpha2: 'SM',
        alpha3: 'SMR',
        numeric: '674',
    },
    {
        country: 'Sao Tome and Principe',
        alpha2: 'ST',
        alpha3: 'STP',
        numeric: '678',
    },
    {
        country: 'Saudi Arabia',
        alpha2: 'SA',
        alpha3: 'SAU',
        numeric: '682',
    },
    {
        country: 'Senegal',
        alpha2: 'SN',
        alpha3: 'SEN',
        numeric: '686',
    },
    {
        country: 'Serbia',
        alpha2: 'RS',
        alpha3: 'SRB',
        numeric: '688',
    },
    {
        country: 'Seychelles',
        alpha2: 'SC',
        alpha3: 'SYC',
        numeric: '690',
    },
    {
        country: 'Sierra Leone',
        alpha2: 'SL',
        alpha3: 'SLE',
        numeric: '694',
    },
    {
        country: 'Singapore',
        alpha2: 'SG',
        alpha3: 'SGP',
        numeric: '702',
    },
    {
        country: 'Sint Maarten',
        alpha2: 'SX',
        alpha3: 'SXM',
        numeric: '534',
    },
    {
        country: 'Slovakia',
        alpha2: 'SK',
        alpha3: 'SVK',
        numeric: '703',
    },
    {
        country: 'Slovenia',
        alpha2: 'SI',
        alpha3: 'SVN',
        numeric: '705',
    },
    {
        country: 'Solomon Islands',
        alpha2: 'SB',
        alpha3: 'SLB',
        numeric: '090',
    },
    {
        country: 'Somalia',
        alpha2: 'SO',
        alpha3: 'SOM',
        numeric: '706',
    },
    {
        country: 'South Africa',
        alpha2: 'ZA',
        alpha3: 'ZAF',
        numeric: '710',
    },
    {
        country: 'South Georgia and the South Sandwich Islands',
        alpha2: 'GS',
        alpha3: 'SGS',
        numeric: '239',
    },
    {
        country: 'South Sudan',
        alpha2: 'SS',
        alpha3: 'SSD',
        numeric: '728',
    },
    {
        country: 'Spain',
        alpha2: 'ES',
        alpha3: 'ESP',
        numeric: '724',
    },
    {
        country: 'Sri Lanka',
        alpha2: 'LK',
        alpha3: 'LKA',
        numeric: '144',
    },
    {
        country: 'Sudan',
        alpha2: 'SD',
        alpha3: 'SDN',
        numeric: '729',
    },
    {
        country: 'Suriname',
        alpha2: 'SR',
        alpha3: 'SUR',
        numeric: '740',
    },
    {
        country: 'Svalbard and Jan Mayen',
        alpha2: 'SJ',
        alpha3: 'SJM',
        numeric: '744',
    },
    {
        country: 'Swaziland',
        alpha2: 'SZ',
        alpha3: 'SWZ',
        numeric: '748',
    },
    {
        country: 'Sweden',
        alpha2: 'SE',
        alpha3: 'SWE',
        numeric: '752',
    },
    {
        country: 'Switzerland',
        alpha2: 'CH',
        alpha3: 'CHE',
        numeric: '756',
    },
    {
        country: 'Syrian Arab Republic',
        alpha2: 'SY',
        alpha3: 'SYR',
        numeric: '760',
    },
    {
        country: 'Taiwan, Province of China',
        alpha2: 'TW',
        alpha3: 'TWN',
        numeric: '158',
    },
    {
        country: 'Tajikistan',
        alpha2: 'TJ',
        alpha3: 'TJK',
        numeric: '762',
    },
    {
        country: 'United Republic of Tanzania',
        alpha2: 'TZ',
        alpha3: 'TZA',
        numeric: '834',
    },
    {
        country: 'Thailand',
        alpha2: 'TH',
        alpha3: 'THA',
        numeric: '764',
    },
    {
        country: 'Timor-Leste',
        alpha2: 'TL',
        alpha3: 'TLS',
        numeric: '626',
    },
    {
        country: 'Togo',
        alpha2: 'TG',
        alpha3: 'TGO',
        numeric: '768',
    },
    {
        country: 'Tokelau',
        alpha2: 'TK',
        alpha3: 'TKL',
        numeric: '772',
    },
    {
        country: 'Tonga',
        alpha2: 'TO',
        alpha3: 'TON',
        numeric: '776',
    },
    {
        country: 'Trinidad and Tobago',
        alpha2: 'TT',
        alpha3: 'TTO',
        numeric: '780',
    },
    {
        country: 'Tunisia',
        alpha2: 'TN',
        alpha3: 'TUN',
        numeric: '788',
    },
    {
        country: 'Turkey',
        alpha2: 'TR',
        alpha3: 'TUR',
        numeric: '792',
    },
    {
        country: 'Turkmenistan',
        alpha2: 'TM',
        alpha3: 'TKM',
        numeric: '795',
    },
    {
        country: 'Turks and Caicos Islands',
        alpha2: 'TC',
        alpha3: 'TCA',
        numeric: '796',
    },
    {
        country: 'Tuvalu',
        alpha2: 'TV',
        alpha3: 'TUV',
        numeric: '798',
    },
    {
        country: 'Uganda',
        alpha2: 'UG',
        alpha3: 'UGA',
        numeric: '800',
    },
    {
        country: 'Ukraine',
        alpha2: 'UA',
        alpha3: 'UKR',
        numeric: '804',
    },
    {
        country: 'United Arab Emirates',
        alpha2: 'AE',
        alpha3: 'ARE',
        numeric: '784',
    },
    {
        country: 'United Kingdom of Great Britain and Northern Ireland',
        alpha2: 'GB',
        alpha3: 'GBR',
        numeric: '826',
    },
    {
        country: 'United States of America',
        alpha2: 'US',
        alpha3: 'USA',
        numeric: '840',
    },
    {
        country: 'United States Minor Outlying Islands',
        alpha2: 'UM',
        alpha3: 'UMI',
        numeric: '581',
    },
    {
        country: 'Uruguay',
        alpha2: 'UY',
        alpha3: 'URY',
        numeric: '858',
    },
    {
        country: 'Uzbekistan',
        alpha2: 'UZ',
        alpha3: 'UZB',
        numeric: '860',
    },
    {
        country: 'Vanuatu',
        alpha2: 'VU',
        alpha3: 'VUT',
        numeric: '548',
    },
    {
        country: 'Venezuela (Bolivarian Republic of)',
        alpha2: 'VE',
        alpha3: 'VEN',
        numeric: '862',
    },
    {
        country: 'Viet Nam',
        alpha2: 'VN',
        alpha3: 'VNM',
        numeric: '704',
    },
    {
        country: 'Virgin Islands',
        alpha2: 'VG',
        alpha3: 'VGB',
        numeric: '092',
    },
    {
        country: 'Virgin Islands of the United States',
        alpha2: 'VI',
        alpha3: 'VIR',
        numeric: '850',
    },
    {
        country: 'Wallis and Futuna',
        alpha2: 'WF',
        alpha3: 'WLF',
        numeric: '876',
    },
    {
        country: 'Western Sahara',
        alpha2: 'EH',
        alpha3: 'ESH',
        numeric: '732',
    },
    {
        country: 'Yemen',
        alpha2: 'YE',
        alpha3: 'YEM',
        numeric: '887',
    },
    {
        country: 'Zambia',
        alpha2: 'ZM',
        alpha3: 'ZMB',
        numeric: '894',
    },
    {
        country: 'Zimbabwe',
        alpha2: 'ZW',
        alpha3: 'ZWE',
        numeric: '716',
    },
];
exports["default"] = countries;


/***/ }),

/***/ "./src/global.scss":
/*!*************************!*\
  !*** ./src/global.scss ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof __webpack_require__.g !== 'undefined') { return __webpack_require__.g; }
	throw new Error('unable to locate global object');
}

var globalObject = getGlobal();

module.exports = exports = globalObject.fetch;

// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
	exports["default"] = globalObject.fetch.bind(globalObject);
}

exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;


/***/ }),

/***/ "./node_modules/toastify-js/src/toastify.js":
/*!**************************************************!*\
  !*** ./node_modules/toastify-js/src/toastify.js ***!
  \**************************************************/
/***/ (function(module) {

/*!
 * Toastify js 1.12.0
 * https://github.com/apvarun/toastify-js
 * @license MIT licensed
 *
 * Copyright (C) 2018 Varun A P
 */
(function(root, factory) {
  if ( true && module.exports) {
    module.exports = factory();
  } else {
    root.Toastify = factory();
  }
})(this, function(global) {
  // Object initialization
  var Toastify = function(options) {
      // Returning a new init object
      return new Toastify.lib.init(options);
    },
    // Library version
    version = "1.12.0";

  // Set the default global options
  Toastify.defaults = {
    oldestFirst: true,
    text: "Toastify is awesome!",
    node: undefined,
    duration: 3000,
    selector: undefined,
    callback: function () {
    },
    destination: undefined,
    newWindow: false,
    close: false,
    gravity: "toastify-top",
    positionLeft: false,
    position: '',
    backgroundColor: '',
    avatar: "",
    className: "",
    stopOnFocus: true,
    onClick: function () {
    },
    offset: {x: 0, y: 0},
    escapeMarkup: true,
    ariaLive: 'polite',
    style: {background: ''}
  };

  // Defining the prototype of the object
  Toastify.lib = Toastify.prototype = {
    toastify: version,

    constructor: Toastify,

    // Initializing the object with required parameters
    init: function(options) {
      // Verifying and validating the input object
      if (!options) {
        options = {};
      }

      // Creating the options object
      this.options = {};

      this.toastElement = null;

      // Validating the options
      this.options.text = options.text || Toastify.defaults.text; // Display message
      this.options.node = options.node || Toastify.defaults.node;  // Display content as node
      this.options.duration = options.duration === 0 ? 0 : options.duration || Toastify.defaults.duration; // Display duration
      this.options.selector = options.selector || Toastify.defaults.selector; // Parent selector
      this.options.callback = options.callback || Toastify.defaults.callback; // Callback after display
      this.options.destination = options.destination || Toastify.defaults.destination; // On-click destination
      this.options.newWindow = options.newWindow || Toastify.defaults.newWindow; // Open destination in new window
      this.options.close = options.close || Toastify.defaults.close; // Show toast close icon
      this.options.gravity = options.gravity === "bottom" ? "toastify-bottom" : Toastify.defaults.gravity; // toast position - top or bottom
      this.options.positionLeft = options.positionLeft || Toastify.defaults.positionLeft; // toast position - left or right
      this.options.position = options.position || Toastify.defaults.position; // toast position - left or right
      this.options.backgroundColor = options.backgroundColor || Toastify.defaults.backgroundColor; // toast background color
      this.options.avatar = options.avatar || Toastify.defaults.avatar; // img element src - url or a path
      this.options.className = options.className || Toastify.defaults.className; // additional class names for the toast
      this.options.stopOnFocus = options.stopOnFocus === undefined ? Toastify.defaults.stopOnFocus : options.stopOnFocus; // stop timeout on focus
      this.options.onClick = options.onClick || Toastify.defaults.onClick; // Callback after click
      this.options.offset = options.offset || Toastify.defaults.offset; // toast offset
      this.options.escapeMarkup = options.escapeMarkup !== undefined ? options.escapeMarkup : Toastify.defaults.escapeMarkup;
      this.options.ariaLive = options.ariaLive || Toastify.defaults.ariaLive;
      this.options.style = options.style || Toastify.defaults.style;
      if(options.backgroundColor) {
        this.options.style.background = options.backgroundColor;
      }

      // Returning the current object for chaining functions
      return this;
    },

    // Building the DOM element
    buildToast: function() {
      // Validating if the options are defined
      if (!this.options) {
        throw "Toastify is not initialized";
      }

      // Creating the DOM object
      var divElement = document.createElement("div");
      divElement.className = "toastify on " + this.options.className;

      // Positioning toast to left or right or center
      if (!!this.options.position) {
        divElement.className += " toastify-" + this.options.position;
      } else {
        // To be depreciated in further versions
        if (this.options.positionLeft === true) {
          divElement.className += " toastify-left";
          console.warn('Property `positionLeft` will be depreciated in further versions. Please use `position` instead.')
        } else {
          // Default position
          divElement.className += " toastify-right";
        }
      }

      // Assigning gravity of element
      divElement.className += " " + this.options.gravity;

      if (this.options.backgroundColor) {
        // This is being deprecated in favor of using the style HTML DOM property
        console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
      }

      // Loop through our style object and apply styles to divElement
      for (var property in this.options.style) {
        divElement.style[property] = this.options.style[property];
      }

      // Announce the toast to screen readers
      if (this.options.ariaLive) {
        divElement.setAttribute('aria-live', this.options.ariaLive)
      }

      // Adding the toast message/node
      if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
        // If we have a valid node, we insert it
        divElement.appendChild(this.options.node)
      } else {
        if (this.options.escapeMarkup) {
          divElement.innerText = this.options.text;
        } else {
          divElement.innerHTML = this.options.text;
        }

        if (this.options.avatar !== "") {
          var avatarElement = document.createElement("img");
          avatarElement.src = this.options.avatar;

          avatarElement.className = "toastify-avatar";

          if (this.options.position == "left" || this.options.positionLeft === true) {
            // Adding close icon on the left of content
            divElement.appendChild(avatarElement);
          } else {
            // Adding close icon on the right of content
            divElement.insertAdjacentElement("afterbegin", avatarElement);
          }
        }
      }

      // Adding a close icon to the toast
      if (this.options.close === true) {
        // Create a span for close element
        var closeElement = document.createElement("button");
        closeElement.type = "button";
        closeElement.setAttribute("aria-label", "Close");
        closeElement.className = "toast-close";
        closeElement.innerHTML = "&#10006;";

        // Triggering the removal of toast from DOM on close click
        closeElement.addEventListener(
          "click",
          function(event) {
            event.stopPropagation();
            this.removeElement(this.toastElement);
            window.clearTimeout(this.toastElement.timeOutValue);
          }.bind(this)
        );

        //Calculating screen width
        var width = window.innerWidth > 0 ? window.innerWidth : screen.width;

        // Adding the close icon to the toast element
        // Display on the right if screen width is less than or equal to 360px
        if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
          // Adding close icon on the left of content
          divElement.insertAdjacentElement("afterbegin", closeElement);
        } else {
          // Adding close icon on the right of content
          divElement.appendChild(closeElement);
        }
      }

      // Clear timeout while toast is focused
      if (this.options.stopOnFocus && this.options.duration > 0) {
        var self = this;
        // stop countdown
        divElement.addEventListener(
          "mouseover",
          function(event) {
            window.clearTimeout(divElement.timeOutValue);
          }
        )
        // add back the timeout
        divElement.addEventListener(
          "mouseleave",
          function() {
            divElement.timeOutValue = window.setTimeout(
              function() {
                // Remove the toast from DOM
                self.removeElement(divElement);
              },
              self.options.duration
            )
          }
        )
      }

      // Adding an on-click destination path
      if (typeof this.options.destination !== "undefined") {
        divElement.addEventListener(
          "click",
          function(event) {
            event.stopPropagation();
            if (this.options.newWindow === true) {
              window.open(this.options.destination, "_blank");
            } else {
              window.location = this.options.destination;
            }
          }.bind(this)
        );
      }

      if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
        divElement.addEventListener(
          "click",
          function(event) {
            event.stopPropagation();
            this.options.onClick();
          }.bind(this)
        );
      }

      // Adding offset
      if(typeof this.options.offset === "object") {

        var x = getAxisOffsetAValue("x", this.options);
        var y = getAxisOffsetAValue("y", this.options);

        var xOffset = this.options.position == "left" ? x : "-" + x;
        var yOffset = this.options.gravity == "toastify-top" ? y : "-" + y;

        divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";

      }

      // Returning the generated element
      return divElement;
    },

    // Displaying the toast
    showToast: function() {
      // Creating the DOM object for the toast
      this.toastElement = this.buildToast();

      // Getting the root element to with the toast needs to be added
      var rootElement;
      if (typeof this.options.selector === "string") {
        rootElement = document.getElementById(this.options.selector);
      } else if (this.options.selector instanceof HTMLElement || (typeof ShadowRoot !== 'undefined' && this.options.selector instanceof ShadowRoot)) {
        rootElement = this.options.selector;
      } else {
        rootElement = document.body;
      }

      // Validating if root element is present in DOM
      if (!rootElement) {
        throw "Root element is not defined";
      }

      // Adding the DOM element
      var elementToInsert = Toastify.defaults.oldestFirst ? rootElement.firstChild : rootElement.lastChild;
      rootElement.insertBefore(this.toastElement, elementToInsert);

      // Repositioning the toasts in case multiple toasts are present
      Toastify.reposition();

      if (this.options.duration > 0) {
        this.toastElement.timeOutValue = window.setTimeout(
          function() {
            // Remove the toast from DOM
            this.removeElement(this.toastElement);
          }.bind(this),
          this.options.duration
        ); // Binding `this` for function invocation
      }

      // Supporting function chaining
      return this;
    },

    hideToast: function() {
      if (this.toastElement.timeOutValue) {
        clearTimeout(this.toastElement.timeOutValue);
      }
      this.removeElement(this.toastElement);
    },

    // Removing the element from the DOM
    removeElement: function(toastElement) {
      // Hiding the element
      // toastElement.classList.remove("on");
      toastElement.className = toastElement.className.replace(" on", "");

      // Removing the element from DOM after transition end
      window.setTimeout(
        function() {
          // remove options node if any
          if (this.options.node && this.options.node.parentNode) {
            this.options.node.parentNode.removeChild(this.options.node);
          }

          // Remove the element from the DOM, only when the parent node was not removed before.
          if (toastElement.parentNode) {
            toastElement.parentNode.removeChild(toastElement);
          }

          // Calling the callback function
          this.options.callback.call(toastElement);

          // Repositioning the toasts again
          Toastify.reposition();
        }.bind(this),
        400
      ); // Binding `this` for function invocation
    },
  };

  // Positioning the toasts on the DOM
  Toastify.reposition = function() {

    // Top margins with gravity
    var topLeftOffsetSize = {
      top: 15,
      bottom: 15,
    };
    var topRightOffsetSize = {
      top: 15,
      bottom: 15,
    };
    var offsetSize = {
      top: 15,
      bottom: 15,
    };

    // Get all toast messages on the DOM
    var allToasts = document.getElementsByClassName("toastify");

    var classUsed;

    // Modifying the position of each toast element
    for (var i = 0; i < allToasts.length; i++) {
      // Getting the applied gravity
      if (containsClass(allToasts[i], "toastify-top") === true) {
        classUsed = "toastify-top";
      } else {
        classUsed = "toastify-bottom";
      }

      var height = allToasts[i].offsetHeight;
      classUsed = classUsed.substr(9, classUsed.length-1)
      // Spacing between toasts
      var offset = 15;

      var width = window.innerWidth > 0 ? window.innerWidth : screen.width;

      // Show toast in center if screen with less than or equal to 360px
      if (width <= 360) {
        // Setting the position
        allToasts[i].style[classUsed] = offsetSize[classUsed] + "px";

        offsetSize[classUsed] += height + offset;
      } else {
        if (containsClass(allToasts[i], "toastify-left") === true) {
          // Setting the position
          allToasts[i].style[classUsed] = topLeftOffsetSize[classUsed] + "px";

          topLeftOffsetSize[classUsed] += height + offset;
        } else {
          // Setting the position
          allToasts[i].style[classUsed] = topRightOffsetSize[classUsed] + "px";

          topRightOffsetSize[classUsed] += height + offset;
        }
      }
    }

    // Supporting function chaining
    return this;
  };

  // Helper function to get offset.
  function getAxisOffsetAValue(axis, options) {

    if(options.offset[axis]) {
      if(isNaN(options.offset[axis])) {
        return options.offset[axis];
      }
      else {
        return options.offset[axis] + 'px';
      }
    }

    return '0px';

  }

  function containsClass(elem, yourClass) {
    if (!elem || typeof yourClass !== "string") {
      return false;
    } else if (
      elem.className &&
      elem.className
        .trim()
        .split(/\s+/gi)
        .indexOf(yourClass) > -1
    ) {
      return true;
    } else {
      return false;
    }
  }

  // Setting up the prototype for the init object
  Toastify.lib.init.prototype = Toastify.lib;

  // Returning the Toastify function to be assigned to the window object/module
  return Toastify;
});


/***/ }),

/***/ "./src/components/HTMLCreation.ts":
/*!****************************************!*\
  !*** ./src/components/HTMLCreation.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class HTMLCreation {
    static createElement(tagName, attributes, children = []) {
        const element = document.createElement(tagName);
        Object.keys(attributes).forEach((key) => {
            element.setAttribute(key, attributes[key]);
        });
        children.forEach((child) => {
            if (!child) {
                return;
            }
            if (typeof child === 'string') {
                element.appendChild(document.createTextNode(child));
            }
            else {
                element.appendChild(child);
            }
        });
        return element;
    }
}
exports["default"] = HTMLCreation;


/***/ }),

/***/ "./src/components/app/app.ts":
/*!***********************************!*\
  !*** ./src/components/app/app.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const footerView_1 = __importDefault(__webpack_require__(/*! ../footer/footerView */ "./src/components/footer/footerView.ts"));
const headerView_1 = __importDefault(__webpack_require__(/*! ../header/headerView */ "./src/components/header/headerView.ts"));
const loginView_1 = __importDefault(__webpack_require__(/*! ../login/loginView */ "./src/components/login/loginView.ts"));
const mainView_1 = __importDefault(__webpack_require__(/*! ../main/mainView */ "./src/components/main/mainView.ts"));
const registrationView_1 = __importDefault(__webpack_require__(/*! ../registration/registrationView */ "./src/components/registration/registrationView.ts"));
const router_1 = __importDefault(__webpack_require__(/*! ../router */ "./src/components/router.ts"));
const missingPageView_1 = __importDefault(__webpack_require__(/*! ../missingPage/missingPageView */ "./src/components/missingPage/missingPageView.ts"));
class App {
    constructor() {
        this.isLoggedIn = !!localStorage.getItem('userToken');
        this.router = router_1.default;
        this.body = document.body;
        this.header = new headerView_1.default();
        this.footer = new footerView_1.default();
        this.login = new loginView_1.default();
        this.registration = new registrationView_1.default();
        this.main = new mainView_1.default();
        this.missingPage = new missingPageView_1.default();
        this.setupRouter();
    }
    render() {
        this.renderStartPage();
        this.changePageAlongThePath();
        this.setupEventListeners();
    }
    renderStartPage() {
        this.body.appendChild(this.header.renderHeader(this.isLoggedIn));
        this.body.appendChild(this.main.renderPage());
        this.body.appendChild(this.footer.renderFooter());
    }
    setupEventListeners() {
        this.body.addEventListener('loginEvent', () => {
            this.router.navigateTo('/login');
        });
        this.body.addEventListener('registrationEvent', () => {
            this.router.navigateTo('/registration');
        });
        this.body.addEventListener('backEvent', () => {
            window.history.back();
        });
        this.body.addEventListener('mainPageEvent', () => {
            this.router.navigateTo('/main');
        });
    }
    changeHeaderElement(element) {
        const header = document.querySelector('header');
        if (header) {
            header.innerHTML = element.innerHTML;
        }
    }
    changeMainElement(element) {
        const main = document.querySelector('main');
        if (main) {
            main.innerHTML = element.innerHTML;
        }
    }
    setupRouter() {
        const renderRoute = (path, renderFunction) => {
            this.router.addRoute(path, () => {
                this.isLoggedIn = !!localStorage.getItem('userToken');
                this.changeHeaderElement(this.header.renderHeader(this.isLoggedIn));
                this.header.addEventListeners();
                renderFunction();
            });
        };
        renderRoute('/main', () => {
            this.changeMainElement(this.main.renderPage());
            this.header.addBurgerButton();
            if (this.isLoggedIn) {
                this.header.addLoginButton();
            }
        });
        renderRoute('/login', () => {
            this.changeMainElement(this.login.renderPage());
            this.header.changeLoginButtonToBackButton();
            this.header.addMainPageButton();
            this.login.addEventListeners();
        });
        renderRoute('/registration', () => {
            this.changeMainElement(this.registration.renderPage());
            this.header.changeRegistrationButtonToBackButton();
            this.header.addMainPageButton();
            this.registration.addEventListeners();
        });
    }
    changePageAlongThePath() {
        const startingRoute = window.location.pathname.slice(1);
        const { routes } = this.router;
        if (startingRoute === '') {
            this.renderPageByRoute('main');
        }
        else if (startingRoute === 'login') {
            if (this.isLoggedIn) {
                this.renderPageByRoute('main');
            }
            else {
                this.renderPageByRoute('login');
            }
        }
        else if (startingRoute === 'registration') {
            this.renderPageByRoute('registration');
        }
        else if (routes[startingRoute]) {
            this.renderPageByRoute(startingRoute);
        }
        else {
            this.renderPageByRoute('404page', true);
        }
    }
    renderPageByRoute(route, keepURL = false) {
        if (!keepURL) {
            this.router.navigateTo(`/${route}`);
        }
        else {
            this.changeHeaderElement(this.header.renderHeader(this.isLoggedIn));
            this.header.addEventListeners();
            this.header.addMainPageButton();
            this.header.addBackButton();
            if (route === '404page') {
                this.changeMainElement(this.missingPage.renderPage());
            }
            else {
                const { routes } = this.router;
                if (routes[`/${route}`]) {
                    routes[`/${route}`]();
                }
            }
        }
    }
}
exports["default"] = App;


/***/ }),

/***/ "./src/components/commerceToolsAPI.ts":
/*!********************************************!*\
  !*** ./src/components/commerceToolsAPI.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const sdk_client_v2_1 = __webpack_require__(/*! @commercetools/sdk-client-v2 */ "./node_modules/@commercetools/sdk-client-v2/dist/commercetools-sdk-client-v2.browser.esm.js");
const platform_sdk_1 = __webpack_require__(/*! @commercetools/platform-sdk */ "./node_modules/@commercetools/platform-sdk/dist/commercetools-platform-sdk.browser.esm.js");
const data_1 = __webpack_require__(/*! ./data */ "./src/components/data.ts");
class CommerceToolsAPI {
    constructor() {
        this.apiRoot = null;
        this.ctpClient = null;
        this.authMiddlewareOptions = {
            host: data_1.authHostUrl,
            projectKey: data_1.projectKey,
            credentials: {
                clientId: data_1.clientId,
                clientSecret: data_1.clientSecret,
            },
            scopes: data_1.defaultCustomerScope,
            fetch,
        };
        this.httpMiddlewareOptions = {
            host: data_1.apiHostUrl,
            fetch,
        };
    }
    createPasswordFlowOptions(username, password) {
        return {
            host: data_1.authHostUrl,
            projectKey: data_1.projectKey,
            credentials: {
                clientId: data_1.clientId,
                clientSecret: data_1.clientSecret,
                user: {
                    username,
                    password,
                },
            },
            scopes: data_1.defaultCustomerScope,
            fetch,
            tokenCache: data_1.userTokenCache,
        };
    }
    createCredentialsClient() {
        return new sdk_client_v2_1.ClientBuilder()
            .withProjectKey(data_1.projectKey)
            .withClientCredentialsFlow(this.authMiddlewareOptions)
            .withHttpMiddleware(this.httpMiddlewareOptions)
            .withLoggerMiddleware()
            .build();
    }
    createPasswordClient(options) {
        return new sdk_client_v2_1.ClientBuilder()
            .withProjectKey(data_1.projectKey)
            .withPasswordFlow(options)
            .withHttpMiddleware(this.httpMiddlewareOptions)
            .withLoggerMiddleware()
            .build();
    }
    login(email, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.createPasswordFlowOptions(email, password);
            this.ctpClient = this.createPasswordClient(options);
            this.apiRoot = (0, platform_sdk_1.createApiBuilderFromCtpClient)(this.ctpClient).withProjectKey({ projectKey: data_1.projectKey });
            let response;
            if (this.apiRoot) {
                response = yield this.apiRoot
                    .me()
                    .login()
                    .post({
                    body: {
                        email,
                        password,
                    },
                })
                    .execute();
            }
            localStorage.setItem('userToken', data_1.userTokenCache.get().token);
            return response;
        });
    }
    register(email, password, firstName, lastName, dateOfBirth, billingAddress, shippingAddress, isBillingAddressDefault, isShippingAddressDefault) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ctpClient = this.createCredentialsClient();
            this.apiRoot = (0, platform_sdk_1.createApiBuilderFromCtpClient)(this.ctpClient).withProjectKey({ projectKey: data_1.projectKey });
            let response;
            const addresses = [billingAddress, shippingAddress];
            let defaultBillingIndex;
            let defaultShippingIndex;
            if (isBillingAddressDefault) {
                defaultBillingIndex = addresses.indexOf(billingAddress);
            }
            if (isShippingAddressDefault) {
                defaultShippingIndex = addresses.indexOf(shippingAddress);
            }
            const customerDraft = {
                email,
                password,
                firstName,
                lastName,
                dateOfBirth,
                addresses,
                billingAddresses: [addresses.indexOf(billingAddress)],
                shippingAddresses: [addresses.indexOf(shippingAddress)],
                defaultBillingAddress: defaultBillingIndex !== undefined ? defaultBillingIndex : undefined,
                defaultShippingAddress: defaultShippingIndex !== undefined ? defaultShippingIndex : undefined,
            };
            if (this.apiRoot) {
                response = yield this.apiRoot
                    .customers()
                    .post({
                    body: customerDraft,
                })
                    .execute();
            }
            yield this.login(email, password);
            return response;
        });
    }
    emailCheck(email) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ctpClient = this.createCredentialsClient();
            this.apiRoot = (0, platform_sdk_1.createApiBuilderFromCtpClient)(this.ctpClient).withProjectKey({ projectKey: data_1.projectKey });
            let response;
            if (this.apiRoot) {
                response = yield this.apiRoot
                    .customers()
                    .get({
                    queryArgs: {
                        where: `email="${email}"`,
                    },
                })
                    .execute();
            }
            return response;
        });
    }
}
exports["default"] = CommerceToolsAPI;


/***/ }),

/***/ "./src/components/data.ts":
/*!********************************!*\
  !*** ./src/components/data.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.userTokenCache = exports.defaultCustomerScope = exports.apiHostUrl = exports.authHostUrl = exports.projectKey = exports.clientSecret = exports.clientId = void 0;
const userTokenCache_1 = __importDefault(__webpack_require__(/*! ./userTokenCache */ "./src/components/userTokenCache.ts"));
const clientId = "MISSING_ENV_VAR".CLIENT_ID || '';
exports.clientId = clientId;
const clientSecret = "MISSING_ENV_VAR".CLIENT_SECRET || '';
exports.clientSecret = clientSecret;
const projectKey = "MISSING_ENV_VAR".PROJECT_KEY || '';
exports.projectKey = projectKey;
const authHostUrl = 'https://auth.eu-central-1.aws.commercetools.com';
exports.authHostUrl = authHostUrl;
const apiHostUrl = 'https://api.eu-central-1.aws.commercetools.com';
exports.apiHostUrl = apiHostUrl;
const defaultCustomerScope = [
    'view_api_clients:final-task manage_stores:final-task manage_shipping_methods:final-task manage_extensions:final-task introspect_oauth_tokens:final-task manage_my_shopping_lists:final-task manage_standalone_prices:final-task manage_states:final-task manage_my_payments:final-task manage_cart_discounts:final-task manage_customers:final-task manage_payments:final-task manage_order_edits:final-task manage_customer_groups:final-task manage_products:final-task manage_my_profile:final-task manage_subscriptions:final-task manage_types:final-task manage_product_selections:final-task manage_attribute_groups:final-task manage_tax_categories:final-task manage_discount_codes:final-task create_anonymous_token:final-task manage_my_orders:final-task manage_shopping_lists:final-task manage_categories:final-task manage_orders:final-task',
];
exports.defaultCustomerScope = defaultCustomerScope;
const userTokenCache = new userTokenCache_1.default();
exports.userTokenCache = userTokenCache;


/***/ }),

/***/ "./src/components/footer/footerView.ts":
/*!*********************************************!*\
  !*** ./src/components/footer/footerView.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const HTMLCreation_1 = __importDefault(__webpack_require__(/*! ../HTMLCreation */ "./src/components/HTMLCreation.ts"));
const logoRSSchool_png_1 = __importDefault(__webpack_require__(/*! ../../assets/logoRSSchool.png */ "./src/assets/logoRSSchool.png"));
class Footer {
    renderFooter() {
        const footer = HTMLCreation_1.default.createElement('footer', { class: 'footer-dashboard' }, [
            HTMLCreation_1.default.createElement('div', { class: 'footer-dashboard__links' }, [
                HTMLCreation_1.default.createElement('p', { class: 'footer-dashboard__links__text' }, ['NLC TEAM']),
                HTMLCreation_1.default.createElement('a', { href: 'https://github.com/AnastasiiaRamona', target: '_blank' }, [
                    'anastasiiaramona',
                ]),
                HTMLCreation_1.default.createElement('a', { href: 'https://github.com/aleks6699', target: '_blank' }, ['aleks6699']),
                HTMLCreation_1.default.createElement('a', { href: 'https://github.com/MartiP54', target: '_blank' }, ['MartiP54']),
            ]),
            HTMLCreation_1.default.createElement('a', { href: 'https://rs.school/', class: 'footer__link-rsschool', target: '_blank' }, [
                HTMLCreation_1.default.createElement('img', { src: logoRSSchool_png_1.default, alt: 'RSSchool Logo', class: 'footer__icon' }),
                'Rolling Scopes School, 2024',
            ]),
        ]);
        return footer;
    }
}
exports["default"] = Footer;


/***/ }),

/***/ "./src/components/header/headerView.ts":
/*!*********************************************!*\
  !*** ./src/components/header/headerView.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const HTMLCreation_1 = __importDefault(__webpack_require__(/*! ../HTMLCreation */ "./src/components/HTMLCreation.ts"));
const dog_png_1 = __importDefault(__webpack_require__(/*! ../../assets/dog.png */ "./src/assets/dog.png"));
const cat_png_1 = __importDefault(__webpack_require__(/*! ../../assets/cat.png */ "./src/assets/cat.png"));
const paw_png_1 = __importDefault(__webpack_require__(/*! ../../assets/paw.png */ "./src/assets/paw.png"));
class Header {
    constructor() {
        this.backButtonTextContent = ' Back';
    }
    renderHeader(isLoggedIn) {
        const textButton = isLoggedIn ? 'Log out' : 'Login';
        const header = HTMLCreation_1.default.createElement('header', { class: 'upper-dashboard' }, [
            HTMLCreation_1.default.createElement('div', { class: 'heading-and-image' }, [
                HTMLCreation_1.default.createElement('img', { class: 'cat-image', src: cat_png_1.default, alt: 'cat' }),
                HTMLCreation_1.default.createElement('div', { class: 'heading' }, [
                    HTMLCreation_1.default.createElement('h1', { class: 'title' }, [
                        'Paws & Claws',
                        HTMLCreation_1.default.createElement('img', {
                            class: 'paw__image',
                            src: paw_png_1.default,
                            alt: 'paw',
                        }),
                    ]),
                    HTMLCreation_1.default.createElement('h2', { class: 'subtitle' }, ['Online Pet Shop']),
                ]),
            ]),
            HTMLCreation_1.default.createElement('div', { class: 'upper-dashboard__buttons' }, [
                HTMLCreation_1.default.createElement('button', { class: 'upper-dashboard__logout-button' }, [`${textButton}`]),
                HTMLCreation_1.default.createElement('button', { class: 'upper-dashboard__register-button' }, ['Register']),
                HTMLCreation_1.default.createElement('img', {
                    class: 'upper-dashboard__image',
                    src: dog_png_1.default,
                    alt: 'dog',
                }),
            ]),
        ]);
        return header;
    }
    changeLoginButtonToBackButton() {
        const loginButton = document.querySelector('.upper-dashboard__logout-button');
        if (loginButton) {
            loginButton.textContent = this.backButtonTextContent;
        }
    }
    changeRegistrationButtonToBackButton() {
        const registrationButton = document.querySelector('.upper-dashboard__register-button');
        if (registrationButton) {
            registrationButton.textContent = this.backButtonTextContent;
        }
    }
    addBurgerButton() {
        const buttonsDiv = document.querySelector('.upper-dashboard__buttons');
        const burgerButton = HTMLCreation_1.default.createElement('button', { class: 'upper-dashboard__burger-menu' }, [
            HTMLCreation_1.default.createElement('div', { class: 'upper-dashboard__burger-menu__first-part' }),
            HTMLCreation_1.default.createElement('div', { class: 'upper-dashboard__burger-menu__second-part' }),
        ]);
        buttonsDiv === null || buttonsDiv === void 0 ? void 0 : buttonsDiv.appendChild(burgerButton);
        const firstPart = document.querySelector('.upper-dashboard__burger-menu__first-part');
        const secondPart = document.querySelector('.upper-dashboard__burger-menu__second-part');
        const leftDashboard = document.querySelector('.left-dashboard');
        burgerButton.addEventListener('click', () => {
            if (firstPart.classList.contains('active')) {
                firstPart.classList.remove('active');
                secondPart.classList.remove('active');
                leftDashboard.classList.remove('active');
            }
            else {
                firstPart.classList.add('active');
                secondPart.classList.add('active');
                leftDashboard.classList.add('active');
            }
        });
    }
    addLoginButton() {
        const buttonsDiv = document.querySelector('.upper-dashboard__buttons');
        const loginButton = HTMLCreation_1.default.createElement('button', { class: 'button-for-check' }, ['Login']);
        buttonsDiv === null || buttonsDiv === void 0 ? void 0 : buttonsDiv.appendChild(loginButton);
        loginButton.addEventListener('click', () => {
            const mainPageEvent = new CustomEvent('mainPageEvent');
            document.body.dispatchEvent(mainPageEvent);
        });
    }
    addMainPageButton() {
        const buttonsDiv = document.querySelector('.upper-dashboard__buttons');
        const mainPageButton = HTMLCreation_1.default.createElement('button', { class: 'main-page-button' }, ['Main page ']);
        buttonsDiv === null || buttonsDiv === void 0 ? void 0 : buttonsDiv.appendChild(mainPageButton);
        mainPageButton.addEventListener('click', () => {
            const mainPageEvent = new CustomEvent('mainPageEvent');
            document.body.dispatchEvent(mainPageEvent);
        });
    }
    addBackButton() {
        const buttonsDiv = document.querySelector('.upper-dashboard__buttons');
        const backButton = HTMLCreation_1.default.createElement('button', { class: 'back-button' }, [this.backButtonTextContent]);
        buttonsDiv === null || buttonsDiv === void 0 ? void 0 : buttonsDiv.appendChild(backButton);
        backButton.addEventListener('click', () => {
            const backEvent = new CustomEvent('backEvent');
            document.body.dispatchEvent(backEvent);
        });
    }
    addEventListeners() {
        const loginButton = document.querySelector('.upper-dashboard__logout-button');
        if (loginButton) {
            loginButton.addEventListener('click', () => {
                if (loginButton.textContent === 'Log out') {
                    const loginEvent = new CustomEvent('loginEvent');
                    document.body.dispatchEvent(loginEvent);
                    localStorage.clear();
                }
                else if (loginButton.textContent === 'Login') {
                    const loginEvent = new CustomEvent('loginEvent');
                    document.body.dispatchEvent(loginEvent);
                }
                else {
                    const backEvent = new CustomEvent('backEvent');
                    document.body.dispatchEvent(backEvent);
                }
            });
        }
        const registrationButton = document.querySelector('.upper-dashboard__register-button');
        if (registrationButton) {
            registrationButton.addEventListener('click', () => {
                if (registrationButton.textContent === 'Register') {
                    const registrationEvent = new CustomEvent('registrationEvent');
                    document.body.dispatchEvent(registrationEvent);
                }
                else {
                    const backEvent = new CustomEvent('backEvent');
                    document.body.dispatchEvent(backEvent);
                }
            });
        }
        const title = document.querySelector('.title');
        if (title) {
            title.addEventListener('click', () => {
                const mainPageEvent = new CustomEvent('mainPageEvent');
                document.body.dispatchEvent(mainPageEvent);
            });
        }
    }
}
exports["default"] = Header;


/***/ }),

/***/ "./src/components/login/loginController.ts":
/*!*************************************************!*\
  !*** ./src/components/login/loginController.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const loginModel_1 = __importDefault(__webpack_require__(/*! ./loginModel */ "./src/components/login/loginModel.ts"));
class LoginController {
    constructor() {
        this.model = new loginModel_1.default();
    }
    validateForm(emailInput, passwordInput) {
        const firstNameValid = this.model.validateEmail(emailInput.value);
        const lastNameValid = this.model.validatePassword(passwordInput.value);
        return firstNameValid && lastNameValid;
    }
    validateEmailInput(event) {
        const input = event.currentTarget;
        const isInputValid = this.model.validateEmail(input.value);
        if (isInputValid) {
            input.setCustomValidity('');
            this.updateInputValidity(input, true);
            return;
        }
        const errorMessage = this.model.createEmailValidationMessage(input.value);
        input.setCustomValidity(errorMessage);
        input.reportValidity();
        this.updateInputValidity(input, false);
    }
    validatePasswordInput(event) {
        const input = event.currentTarget;
        const isInputValid = this.model.validatePassword(input.value);
        if (isInputValid) {
            input.setCustomValidity('');
            this.updateInputValidity(input, true);
            return;
        }
        const errorMessage = this.model.createPasswordValidationMessage(input.value);
        input.setCustomValidity(errorMessage);
        input.reportValidity();
        this.updateInputValidity(input, false);
    }
    updateInputValidity(input, isValid) {
        if (!isValid) {
            input.classList.add('login__input-invalid');
        }
        else {
            input.classList.remove('login__input-invalid');
        }
    }
    updateButtonValidity(button, emailInput, passwordInput, errorText) {
        if (!button || !emailInput || !passwordInput) {
            return;
        }
        button.classList.toggle('login__button-active', this.validateForm(emailInput, passwordInput));
        errorText === null || errorText === void 0 ? void 0 : errorText.classList.add('login__error-hide');
        if (this.validateForm(emailInput, passwordInput)) {
            button.removeAttribute('disabled');
        }
        else {
            button.setAttribute('disabled', 'true');
        }
    }
    controlPassword(event, passwordInput) {
        event.preventDefault();
        const input = event.currentTarget;
        input.classList.toggle('login__password-hide');
        if (input.classList.contains('login__password-hide')) {
            passwordInput.setAttribute('type', 'password');
        }
        else
            passwordInput.setAttribute('type', 'text');
    }
    login(event, email, password) {
        return __awaiter(this, void 0, void 0, function* () {
            event.preventDefault();
            let result;
            const response = yield this.model.login(email, password);
            if (response) {
                result = 'loginSuccess';
            }
            else {
                const emailStatus = yield this.model.emailCheck(email);
                if (emailStatus) {
                    result = 'errorPassword';
                }
                else {
                    result = 'errorEmail';
                }
            }
            return result;
        });
    }
}
exports["default"] = LoginController;


/***/ }),

/***/ "./src/components/login/loginModel.ts":
/*!********************************************!*\
  !*** ./src/components/login/loginModel.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const commerceToolsAPI_1 = __importDefault(__webpack_require__(/*! ../commerceToolsAPI */ "./src/components/commerceToolsAPI.ts"));
class LoginModel {
    constructor() {
        this.commerceToolsAPI = new commerceToolsAPI_1.default();
    }
    validateEmail(email) {
        return /^[A-Za-z0-9._+-]+@[A-Za-z0-9-.]+\.+.[A-Za-z]{1,}$/i.test(email);
    }
    createEmailValidationMessage(email) {
        if (!email)
            return 'Email is required';
        if (!/^\S.*\S$/.test(email))
            return 'Email address must not contain leading or trailing whitespace.';
        if (!/^[a-zA-Z-._+-@]+$/.test(email))
            return 'You can only use hyphens underscores and English letters.';
        if (!/@/.test(email))
            return 'The email address must contain @.';
        if (!/^[^@]/.test(email))
            return 'The email address cannot start with @.';
        if (!/^[a-zA-Z0-9.-]+@[A-Za-z0-9-.]+\.[a-zA-Z]{1,}$/.test(email))
            return 'Email address is not complete, enter domain';
        return '';
    }
    validatePassword(password) {
        return /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[0-9a-zA-Z]{8,}$/.test(password);
    }
    createPasswordValidationMessage(password) {
        if (!password)
            return 'Password is required';
        if (!/^\S.*\S$/.test(password))
            return 'Password must not contain leading or trailing whitespace.';
        if (!/^[0-9a-zA-Z]+$/.test(password))
            return 'You can only use English letters and digits';
        if (password.length < 8)
            return 'Password should be at least 8 characters long.';
        if (!/\d/.test(password))
            return 'Password should contain at least one digit.';
        if (!/[a-z]/.test(password))
            return 'Password should contain at least one lowercase English letter.';
        if (!/[A-Z]/.test(password))
            return 'Password should contain at least one uppercase English letter.';
        return '';
    }
    login(email, password) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.commerceToolsAPI.login(email, password);
                if (response) {
                    const mainPageEvent = new CustomEvent('mainPageEvent');
                    document.body.dispatchEvent(mainPageEvent);
                    return true;
                }
                return false;
            }
            catch (error) {
                return false;
            }
        });
    }
    emailCheck(email) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.commerceToolsAPI.emailCheck(email);
                if (response === null || response === void 0 ? void 0 : response.body.results.length) {
                    return true;
                }
                return false;
            }
            catch (error) {
                return false;
            }
        });
    }
}
exports["default"] = LoginModel;


/***/ }),

/***/ "./src/components/login/loginView.ts":
/*!*******************************************!*\
  !*** ./src/components/login/loginView.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const HTMLCreation_1 = __importDefault(__webpack_require__(/*! ../HTMLCreation */ "./src/components/HTMLCreation.ts"));
const loginController_1 = __importDefault(__webpack_require__(/*! ./loginController */ "./src/components/login/loginController.ts"));
const parrot_png_1 = __importDefault(__webpack_require__(/*! ../../assets/parrot.png */ "./src/assets/parrot.png"));
class Login {
    constructor() {
        this.controller = new loginController_1.default();
    }
    renderPage() {
        const loginWrapper = HTMLCreation_1.default.createElement('section', { class: 'login__wrapper' }, [
            HTMLCreation_1.default.createElement('form', {
                id: 'loginForm',
                class: 'login__form form',
            }, [
                HTMLCreation_1.default.createElement('input', { type: 'text', placeholder: 'Email', class: 'login__email input' }),
                HTMLCreation_1.default.createElement('p', { class: 'login__email-error login__error-hide' }, [
                    `\u26A0\uFE0F There are no registered users with this email address. Check your email address or register.`,
                ]),
                HTMLCreation_1.default.createElement('div', { class: 'login__password-wrapper' }, [
                    HTMLCreation_1.default.createElement('input', {
                        type: 'password',
                        placeholder: 'Password',
                        class: 'login__password-input input',
                    }),
                    HTMLCreation_1.default.createElement('button', { class: 'login__password-control login__password-hide' }),
                ]),
                HTMLCreation_1.default.createElement('p', { class: 'login__password-error login__error-hide' }, [
                    `\u26A0\uFE0F The password is incorrect, please check the password is correct. The password is case sensitive, please check your caps lock.`,
                ]),
                HTMLCreation_1.default.createElement('button', { type: 'submit', form: 'loginForm', class: 'login__submit-button button', disabled: 'true' }, [`Login`]),
            ]),
        ]);
        const iconPassword = loginWrapper.querySelector('.login__password-control');
        iconPassword.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path fill = black" clip-rule="evenodd" d="M6.30147 15.5771C4.77832 14.2684 3.6904 12.7726 3.18002 12C3.6904 11.2274 4.77832 9.73158 6.30147 8.42294C7.87402 7.07185 9.81574 6 12 6C14.1843 6 16.1261 7.07185 17.6986 8.42294C19.2218 9.73158 20.3097 11.2274 20.8201 12C20.3097 12.7726 19.2218 14.2684 17.6986 15.5771C16.1261 16.9282 14.1843 18 12 18C9.81574 18 7.87402 16.9282 6.30147 15.5771ZM12 4C9.14754 4 6.75717 5.39462 4.99812 6.90595C3.23268 8.42276 2.00757 10.1376 1.46387 10.9698C1.05306 11.5985 1.05306 12.4015 1.46387 13.0302C2.00757 13.8624 3.23268 15.5772 4.99812 17.0941C6.75717 18.6054 9.14754 20 12 20C14.8525 20 17.2429 18.6054 19.002 17.0941C20.7674 15.5772 21.9925 13.8624 22.5362 13.0302C22.947 12.4015 22.947 11.5985 22.5362 10.9698C21.9925 10.1376 20.7674 8.42276 19.002 6.90595C17.2429 5.39462 14.8525 4 12 4ZM10 12C10 10.8954 10.8955 10 12 10C13.1046 10 14 10.8954 14 12C14 13.1046 13.1046 14 12 14C10.8955 14 10 13.1046 10 12ZM12 8C9.7909 8 8.00004 9.79086 8.00004 12C8.00004 14.2091 9.7909 16 12 16C14.2092 16 16 14.2091 16 12C16 9.79086 14.2092 8 12 8Z" fill="#000000"/>
    </svg>`;
        const imageParrot = HTMLCreation_1.default.createElement('img', {
            class: 'login__main-container__image',
            src: parrot_png_1.default,
            alt: 'parrot',
        });
        const sectionContainer = HTMLCreation_1.default.createElement('section', { class: 'login__main-container' }, [
            imageParrot,
            loginWrapper,
        ]);
        const main = HTMLCreation_1.default.createElement('main', { class: 'login__main' }, [sectionContainer]);
        return main;
    }
    addEventListeners() {
        const emailInput = document.querySelector('.login__email');
        const passwordInput = document.querySelector('.login__password-input');
        const submitButtonInput = document.querySelector('.login__submit-button');
        const passwordButtonControl = document.querySelector('.login__password-control');
        const emailError = document.querySelector('.login__email-error');
        const passwordError = document.querySelector('.login__password-error');
        emailInput.addEventListener('input', (event) => {
            this.controller.updateButtonValidity(submitButtonInput, emailInput, passwordInput, emailError);
            this.controller.validateEmailInput(event);
        });
        passwordInput.addEventListener('input', (event) => {
            this.controller.updateButtonValidity(submitButtonInput, emailInput, passwordInput, passwordError);
            this.controller.validatePasswordInput(event);
        });
        passwordButtonControl.addEventListener('click', (event) => {
            this.controller.controlPassword(event, passwordInput);
        });
        submitButtonInput.addEventListener('click', (event) => __awaiter(this, void 0, void 0, function* () {
            const resultLogin = yield this.controller.login(event, emailInput.value, passwordInput.value);
            this.checkLogin(resultLogin);
        }));
    }
    checkLogin(resultLogin) {
        const emailInput = document.querySelector('.login__email');
        const passwordInput = document.querySelector('.login__password-input');
        const emailError = document.querySelector('.login__email-error');
        const passwordError = document.querySelector('.login__password-error');
        switch (resultLogin) {
            case 'loginSuccess':
                break;
            case 'errorEmail':
                emailInput.classList.add('login__input-invalid');
                emailError.classList.remove('login__error-hide');
                break;
            case 'errorPassword':
                passwordInput.classList.add('login__input-invalid');
                passwordError.classList.remove('login__error-hide');
                break;
            default:
        }
    }
}
exports["default"] = Login;


/***/ }),

/***/ "./src/components/main/mainView.ts":
/*!*****************************************!*\
  !*** ./src/components/main/mainView.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const HTMLCreation_1 = __importDefault(__webpack_require__(/*! ../HTMLCreation */ "./src/components/HTMLCreation.ts"));
class Main {
    renderPage() {
        const mainField = HTMLCreation_1.default.createElement('main', { class: 'main-field' }, [
            HTMLCreation_1.default.createElement('section', { class: 'main-area' }, [
                HTMLCreation_1.default.createElement('p', { class: 'main-area__text' }, [
                    `Welcome to Paws & Claws, your ultimate destination for online pet shopping!`,
                ]),
            ]),
            HTMLCreation_1.default.createElement('section', { class: 'left-dashboard' }, [
                HTMLCreation_1.default.createElement('button', { class: 'left-dashboard__button clicked' }, ['Main page ']),
                HTMLCreation_1.default.createElement('button', { class: 'left-dashboard__button' }, ['Catalog Product ']),
                HTMLCreation_1.default.createElement('button', { class: 'left-dashboard__button' }, ['User Profile ']),
                HTMLCreation_1.default.createElement('button', { class: 'left-dashboard__button' }, ['Basket ']),
                HTMLCreation_1.default.createElement('button', { class: 'left-dashboard__button' }, ['About Us ']),
            ]),
        ]);
        return mainField;
    }
}
exports["default"] = Main;


/***/ }),

/***/ "./src/components/missingPage/missingPageView.ts":
/*!*******************************************************!*\
  !*** ./src/components/missingPage/missingPageView.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const HTMLCreation_1 = __importDefault(__webpack_require__(/*! ../HTMLCreation */ "./src/components/HTMLCreation.ts"));
const dogs_png_1 = __importDefault(__webpack_require__(/*! ../../assets/dogs.png */ "./src/assets/dogs.png"));
const _404Error_png_1 = __importDefault(__webpack_require__(/*! ../../assets/404Error.png */ "./src/assets/404Error.png"));
class MissingPage {
    renderPage() {
        const mainElement = HTMLCreation_1.default.createElement('main', { class: 'missing-page' });
        const imgElement = HTMLCreation_1.default.createElement('img', {
            class: 'missing-page__image',
            src: dogs_png_1.default,
            alt: '404 Image',
        });
        const imgErrorElement = HTMLCreation_1.default.createElement('img', {
            class: 'missing-page__image-error',
            src: _404Error_png_1.default,
            alt: '404 Image',
        });
        const headingElement = HTMLCreation_1.default.createElement('h2', {
            class: 'missing-page__heading',
        }, ['Sorry, the page you requested was not found  Please select a different page or go back.']);
        const container = HTMLCreation_1.default.createElement('div', { class: 'container-missing-page' }, [
            imgErrorElement,
            headingElement,
        ]);
        mainElement.appendChild(container);
        mainElement.appendChild(imgElement);
        return mainElement;
    }
}
exports["default"] = MissingPage;


/***/ }),

/***/ "./src/components/registration/componentsUI/fieldsetElement.ts":
/*!*********************************************************************!*\
  !*** ./src/components/registration/componentsUI/fieldsetElement.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const HTMLCreation_1 = __importDefault(__webpack_require__(/*! ../../HTMLCreation */ "./src/components/HTMLCreation.ts"));
class FieldsetRegistrationAddress {
    constructor(className, title) {
        this.className = className;
        this.title = title;
    }
    renderDatalist() {
        const countries = ['United States', 'Germany', 'Italy'];
        const options = countries.map((country) => HTMLCreation_1.default.createElement('option', { value: country }));
        return HTMLCreation_1.default.createElement('datalist', { id: 'countryList' }, options);
    }
    renderFieldsetRegistrationAddress() {
        const fieldsetRegistrationAddress = HTMLCreation_1.default.createElement('fieldset', { class: `fieldset fieldset${this.className}` }, [
            HTMLCreation_1.default.createElement('legend', { class: 'legend-registration' }, [this.title]),
            HTMLCreation_1.default.createElement('label', { class: `label label-street${this.className}` }, ['Street:']),
            HTMLCreation_1.default.createElement('input', {
                type: 'text',
                class: `input-street${this.className} input input-street `,
                placeholder: 'street',
                required: 'true',
                name: 'street',
            }),
            HTMLCreation_1.default.createElement('label', { class: `label label-city${this.className}` }, ['City:']),
            HTMLCreation_1.default.createElement('input', {
                type: 'text',
                class: `input-city${this.className} input input-city`,
                placeholder: 'city',
                required: 'true',
                name: 'city',
            }),
            HTMLCreation_1.default.createElement('label', { class: `label label-code${this.className}` }, ['Postal code:']),
            HTMLCreation_1.default.createElement('input', {
                type: 'text',
                class: `input-code${this.className} input input-code`,
                placeholder: 'postal code',
                required: 'true',
                name: 'postal code',
            }),
            HTMLCreation_1.default.createElement('label', { class: `label label-country${this.className}` }, ['Country']),
            HTMLCreation_1.default.createElement('input', {
                type: 'text',
                class: `input-country${this.className} input input-country`,
                placeholder: 'select one country',
                required: 'true',
                list: 'countryList',
                name: 'country',
            }),
            this.renderDatalist(),
            HTMLCreation_1.default.createElement('label', { class: `label label-name${this.className}` }, [
                'Default delivery address',
            ]),
            HTMLCreation_1.default.createElement('input', {
                type: 'checkbox',
                class: `check-default${this.className} input`,
                name: 'address',
            }),
        ]);
        return fieldsetRegistrationAddress;
    }
    renderFieldsetRegistrationUsers() {
        const fieldsetRegistrationUsers = HTMLCreation_1.default.createElement('fieldset', { class: 'fieldset-users' }, [
            HTMLCreation_1.default.createElement('legend', { class: 'legend-registration' }, ['Registration Users form']),
            HTMLCreation_1.default.createElement('label', { class: 'label label-mail' }, ['Mail:']),
            HTMLCreation_1.default.createElement('input', {
                type: 'email',
                class: 'input-mail input',
                placeholder: 'example@email.com',
                required: 'true',
            }),
            HTMLCreation_1.default.createElement('label', { class: 'label label-password' }, ['Password:']),
            HTMLCreation_1.default.createElement('input', {
                type: 'password',
                class: 'input-password input',
                placeholder: 'password',
                required: 'true',
            }),
            HTMLCreation_1.default.createElement('label', { class: 'label label-username' }, ['Username:']),
            HTMLCreation_1.default.createElement('input', {
                type: 'text',
                class: 'input-username input',
                placeholder: 'username',
                required: 'true',
            }),
            HTMLCreation_1.default.createElement('label', { class: 'label label-surname' }, ['Surname']),
            HTMLCreation_1.default.createElement('input', {
                type: 'text',
                class: 'input-surname input',
                placeholder: 'surname',
                required: 'true',
            }),
            HTMLCreation_1.default.createElement('label', { class: 'label label-date' }, ['Date of birth:']),
            HTMLCreation_1.default.createElement('input', {
                type: 'text',
                class: 'input-date input',
                placeholder: 'DD.MM.YYYY',
                required: 'true',
            }),
        ]);
        return fieldsetRegistrationUsers;
    }
}
exports["default"] = FieldsetRegistrationAddress;


/***/ }),

/***/ "./src/components/registration/registrationController.ts":
/*!***************************************************************!*\
  !*** ./src/components/registration/registrationController.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const registrationModel_1 = __importDefault(__webpack_require__(/*! ./registrationModel */ "./src/components/registration/registrationModel.ts"));
class RegistrationController {
    constructor() {
        this.model = new registrationModel_1.default();
    }
    checkValidate() {
        const form = document.querySelector('.form-registration');
        const inputs = document.querySelectorAll('.input');
        inputs.forEach((input) => {
            if (!(input.type === 'checkbox'))
                input.setCustomValidity('required field');
        });
        form.addEventListener('input', (event) => {
            const element = event.target;
            const { value } = element;
            if (element.classList.contains('input-mail')) {
                if (!/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(value)) {
                    element.setCustomValidity('Email was entered incorrectly');
                }
                else {
                    element.setCustomValidity('');
                }
            }
            if (element.classList.contains('input-password')) {
                if (!/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/.test(value)) {
                    element.setCustomValidity('Enter a minimum of 8 characters, at least 1 uppercase letter, 1 lowercase letter, and 1 number. Only English letters and digits are allowed.');
                }
                else {
                    element.setCustomValidity('');
                }
            }
            if (element.classList.contains('input-street')) {
                if (!/^.+$/.test(value)) {
                    element.setCustomValidity('Street must contain at least one character');
                }
                else {
                    element.setCustomValidity('');
                }
            }
            if (element.classList.contains('input-username') || element.classList.contains('input-surname')) {
                if (!/^[^\d\s!@#$%^&*()_+=[\]{};':"\\|,.<>/?]+$/.test(value)) {
                    element.setCustomValidity('The name or surname must contain at least one character and not contain special characters or numbers.');
                }
                else {
                    element.setCustomValidity('');
                }
            }
            if (element.classList.contains('input-city')) {
                if (!/^[^\W\d_]+$/.test(value)) {
                    element.setCustomValidity('City must contain at least one character and not contain special characters or numbers');
                }
                else {
                    element.setCustomValidity('');
                }
            }
            if (element.classList.contains('input-code')) {
                if (!/^\d{5}$/.test(value)) {
                    element.setCustomValidity('Enter the correct code');
                }
                else {
                    element.setCustomValidity('');
                }
            }
            if (element.classList.contains('input-country')) {
                if (!/(Italy|Germany|United States)/.test(value)) {
                    element.setCustomValidity('Select one country from the list');
                }
                else {
                    element.setCustomValidity('');
                }
            }
            if (element.classList.contains('input-date')) {
                const dateRegex = /^(0[1-9]|[1-2][0-9]|3[0-1])\.(0[1-9]|1[0-2])\.\d{4}$/;
                if (!dateRegex.test(value)) {
                    element.setCustomValidity('Enter the date in the format DD.MM.YYYY');
                }
                else {
                    const [day, month, year] = value.split('.').map(Number);
                    const currentDate = new Date();
                    const userDate = new Date(year, month - 1, day);
                    const minAgeDate = new Date(currentDate.getFullYear() - 13, currentDate.getMonth(), currentDate.getDate());
                    if (minAgeDate < userDate) {
                        element.setCustomValidity('You must be at least 13 years old.');
                    }
                    else {
                        element.setCustomValidity('');
                    }
                }
            }
        });
    }
    changeFormAddresses(billing, shipping, addresses) {
        const inner = document.querySelector('.form-inner');
        const checkboxAddresses = document.querySelector('.input-checkbox__address');
        if (checkboxAddresses.checked) {
            if (inner) {
                inner.innerHTML = '';
                inner.appendChild(addresses);
            }
        }
        else if (inner) {
            inner.innerHTML = '';
            inner.appendChild(billing);
            inner.appendChild(shipping);
        }
    }
    parseDateString(dateString) {
        const [day, month, year] = dateString.split('.');
        const date = `${year}-${month}-${day}`;
        return date;
    }
    getRegistration(email, password, firstName, lastName, dateOfBirth, billingAddress, shippingAddress, isBillingAddressDefault, isShippingAddressDefault) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.model.register(email, password, firstName, lastName, dateOfBirth, billingAddress, shippingAddress, isBillingAddressDefault, isShippingAddressDefault);
            return result;
        });
    }
}
exports["default"] = RegistrationController;


/***/ }),

/***/ "./src/components/registration/registrationModel.ts":
/*!**********************************************************!*\
  !*** ./src/components/registration/registrationModel.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const toastify_js_1 = __importDefault(__webpack_require__(/*! toastify-js */ "./node_modules/toastify-js/src/toastify.js"));
const commerceToolsAPI_1 = __importDefault(__webpack_require__(/*! ../commerceToolsAPI */ "./src/components/commerceToolsAPI.ts"));
class RegistrationModel {
    constructor() {
        this.commerceToolsAPI = new commerceToolsAPI_1.default();
    }
    showResponseMessage(text) {
        (0, toastify_js_1.default)({
            text,
            newWindow: true,
            className: 'info',
            close: true,
            stopOnFocus: true,
            offset: {
                y: 200,
                x: 0,
            },
            duration: 5000,
        }).showToast();
    }
    handleResponse(message, code) {
        if (message) {
            if (message === 'There is already an existing customer with the provided email.') {
                this.showResponseMessage('A user with the specified email already exists. Enter a different email or try to log in.');
            }
            else if (code === 201) {
                this.showResponseMessage(message);
            }
            else if (code === 500 || code === 502 || code === 504 || code === 503) {
                this.showResponseMessage(`${message}, try again later`);
            }
            else
                this.showResponseMessage(message);
        }
    }
    register(email, password, firstName, lastName, dateOfBirth, billingAddress, shippingAddress, isBillingAddressDefault, isShippingAddressDefault) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.commerceToolsAPI.register(email, password, firstName, lastName, dateOfBirth, billingAddress, shippingAddress, isBillingAddressDefault, isShippingAddressDefault);
                const mainPageEvent = new CustomEvent('mainPageEvent');
                document.body.dispatchEvent(mainPageEvent);
                if (response) {
                    if ('statusCode' in response) {
                        this.handleResponse('Welcome Aboard! Your registration was successful.', response.statusCode);
                    }
                }
                return response;
            }
            catch (error) {
                if (error instanceof Error) {
                    if ('code' in error) {
                        this.handleResponse(error.message, error.code);
                    }
                }
                return false;
            }
        });
    }
}
exports["default"] = RegistrationModel;


/***/ }),

/***/ "./src/components/registration/registrationView.ts":
/*!*********************************************************!*\
  !*** ./src/components/registration/registrationView.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const iso_3166_1_1 = __importDefault(__webpack_require__(/*! iso-3166-1 */ "./node_modules/iso-3166-1/dist/index.js"));
const HTMLCreation_1 = __importDefault(__webpack_require__(/*! ../HTMLCreation */ "./src/components/HTMLCreation.ts"));
const registrationController_1 = __importDefault(__webpack_require__(/*! ./registrationController */ "./src/components/registration/registrationController.ts"));
const fieldsetElement_1 = __importDefault(__webpack_require__(/*! ./componentsUI/fieldsetElement */ "./src/components/registration/componentsUI/fieldsetElement.ts"));
class Registration {
    constructor() {
        this.controller = new registrationController_1.default();
        this.billingFieldset = new fieldsetElement_1.default('__billing', 'Billing address form');
        this.shippingFieldset = new fieldsetElement_1.default('__shipping', 'Shipping address form');
        this.addressesFieldset = new fieldsetElement_1.default('__addresses', 'Addresses form');
        this.registrationUsersFieldset = new fieldsetElement_1.default('', '');
    }
    renderForm() {
        const form = HTMLCreation_1.default.createElement('form', { class: 'form  form-registration', action: '/' }, [
            this.registrationUsersFieldset.renderFieldsetRegistrationUsers(),
            HTMLCreation_1.default.createElement('label', { class: 'label label-delivery__criterion' }, [
                'Set as billing and shipping address',
            ]),
            HTMLCreation_1.default.createElement('input', {
                type: 'checkbox',
                class: 'input input-checkbox__address',
            }),
            HTMLCreation_1.default.createElement('div', { class: 'form-inner' }, [
                this.billingFieldset.renderFieldsetRegistrationAddress(),
                this.shippingFieldset.renderFieldsetRegistrationAddress(),
            ]),
            HTMLCreation_1.default.createElement('button', { class: 'button button-registration' }, ['Sign up']),
        ]);
        return form;
    }
    renderPage() {
        const registrationMain = HTMLCreation_1.default.createElement('main', { class: 'registration-main' }, [
            HTMLCreation_1.default.createElement('div', { class: 'container container-registration' }, [this.renderForm()]),
        ]);
        return registrationMain;
    }
    addEventListeners() {
        var _a;
        const billingAddress = this.billingFieldset.renderFieldsetRegistrationAddress();
        const shippingAddress = this.shippingFieldset.renderFieldsetRegistrationAddress();
        const allAddresses = this.addressesFieldset.renderFieldsetRegistrationAddress();
        const checkboxAddresses = document.querySelector('.input-checkbox__address');
        this.controller.checkValidate();
        checkboxAddresses === null || checkboxAddresses === void 0 ? void 0 : checkboxAddresses.addEventListener('change', (event) => {
            event.preventDefault();
            this.controller.changeFormAddresses(billingAddress, shippingAddress, allAddresses);
        });
        (_a = document.querySelector('.form')) === null || _a === void 0 ? void 0 : _a.addEventListener('submit', (event) => __awaiter(this, void 0, void 0, function* () {
            event.preventDefault();
            const inputDateValue = document.querySelector('.input-date').value;
            const dateOfBirth = this.controller.parseDateString(inputDateValue);
            const inputMailValue = document.querySelector('.input-mail').value;
            const inputPasswordValue = document.querySelector('.input-password').value;
            const inputUsernameValue = document.querySelector('.input-username').value;
            const inputSurnameValue = document.querySelector('.input-surname').value;
            let isBillingAddressDefault;
            let isShippingAddressDefault;
            let billingAddressResult;
            let shippingAddressResult;
            const billingAddressInput = document.querySelector('.input-street__billing');
            if (billingAddressInput) {
                billingAddressResult = this.getBillingAddress();
                shippingAddressResult = this.getShippingAddress();
                isBillingAddressDefault = document.querySelector('.check-default__billing').checked;
                isShippingAddressDefault = document.querySelector('.check-default__shipping').checked;
            }
            else {
                billingAddressResult = this.getGeneralAddress();
                shippingAddressResult = this.getGeneralAddress();
                isBillingAddressDefault = document.querySelector('.check-default__addresses').checked;
                isShippingAddressDefault = document.querySelector('.check-default__addresses').checked;
            }
            this.controller.getRegistration(inputMailValue, inputPasswordValue, inputUsernameValue, inputSurnameValue, dateOfBirth, billingAddressResult, shippingAddressResult, isBillingAddressDefault, isShippingAddressDefault);
        }));
    }
    getBillingAddress() {
        var _a;
        const inputStreet = document.querySelector('.input-street__billing').value;
        const inputCity = document.querySelector('.input-city__billing').value;
        const inputPostalCode = document.querySelector('.input-code__billing').value;
        const inputCountry = document.querySelector('.input-country__billing').value;
        let inputCountryCode = ((_a = iso_3166_1_1.default.whereCountry(inputCountry)) === null || _a === void 0 ? void 0 : _a.alpha2) || 'UNDEFINED';
        if (inputCountry === 'United States') {
            inputCountryCode = 'US';
        }
        return {
            country: inputCountryCode,
            streetName: inputStreet,
            postalCode: inputPostalCode,
            city: inputCity,
        };
    }
    getShippingAddress() {
        var _a;
        const inputStreet = document.querySelector('.input-street__shipping').value;
        const inputCity = document.querySelector('.input-city__shipping').value;
        const inputPostalCode = document.querySelector('.input-code__shipping').value;
        const inputCountry = document.querySelector('.input-country__shipping').value;
        let inputCountryCode = ((_a = iso_3166_1_1.default.whereCountry(inputCountry)) === null || _a === void 0 ? void 0 : _a.alpha2) || 'UNDEFINED';
        if (inputCountry === 'United States') {
            inputCountryCode = 'US';
        }
        return {
            country: inputCountryCode,
            streetName: inputStreet,
            postalCode: inputPostalCode,
            city: inputCity,
        };
    }
    getGeneralAddress() {
        var _a;
        const inputStreet = document.querySelector('.input-street__addresses').value;
        const inputCity = document.querySelector('.input-city__addresses').value;
        const inputPostalCode = document.querySelector('.input-code__addresses').value;
        const inputCountry = document.querySelector('.input-country__addresses').value;
        let inputCountryCode = ((_a = iso_3166_1_1.default.whereCountry(inputCountry)) === null || _a === void 0 ? void 0 : _a.alpha2) || 'UNDEFINED';
        if (inputCountry === 'United States') {
            inputCountryCode = 'US';
        }
        return {
            country: inputCountryCode,
            streetName: inputStreet,
            postalCode: inputPostalCode,
            city: inputCity,
        };
    }
}
exports["default"] = Registration;


/***/ }),

/***/ "./src/components/router.ts":
/*!**********************************!*\
  !*** ./src/components/router.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Router {
    constructor() {
        this.routes = {};
        window.addEventListener('popstate', this.handleRouteChange.bind(this));
        window.addEventListener('load', this.handleRouteChange.bind(this));
    }
    addRoute(route, handler) {
        this.routes[route] = handler;
    }
    handleRouteChange() {
        const currentRoute = window.location.pathname;
        const handler = this.routes[currentRoute];
        if (handler) {
            handler();
        }
    }
    navigateTo(route) {
        const absoluteRoute = route.startsWith('/') ? route : `/${route}`;
        window.history.pushState(null, '', absoluteRoute);
        this.handleRouteChange();
    }
}
const router = new Router();
exports["default"] = router;


/***/ }),

/***/ "./src/components/userTokenCache.ts":
/*!******************************************!*\
  !*** ./src/components/userTokenCache.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class UserTokenCache {
    constructor() {
        this.cachedTokenInfo = {
            token: '',
            expirationTime: 0,
        };
    }
    get() {
        return this.cachedTokenInfo;
    }
    set(cache) {
        this.cachedTokenInfo = cache;
    }
}
exports["default"] = UserTokenCache;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const app_1 = __importDefault(__webpack_require__(/*! ./components/app/app */ "./src/components/app/app.ts"));
__webpack_require__(/*! ./style.scss */ "./src/style.scss");
__webpack_require__(/*! ./global.scss */ "./src/global.scss");
const app = new app_1.default();
app.render();


/***/ }),

/***/ "./src/assets/404Error.png":
/*!*********************************!*\
  !*** ./src/assets/404Error.png ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/404Error.png";

/***/ }),

/***/ "./src/assets/cat.png":
/*!****************************!*\
  !*** ./src/assets/cat.png ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/cat.png";

/***/ }),

/***/ "./src/assets/dog.png":
/*!****************************!*\
  !*** ./src/assets/dog.png ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/dog.png";

/***/ }),

/***/ "./src/assets/dogs.png":
/*!*****************************!*\
  !*** ./src/assets/dogs.png ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/dogs.png";

/***/ }),

/***/ "./src/assets/logoRSSchool.png":
/*!*************************************!*\
  !*** ./src/assets/logoRSSchool.png ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/logoRSSchool.png";

/***/ }),

/***/ "./src/assets/parrot.png":
/*!*******************************!*\
  !*** ./src/assets/parrot.png ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/parrot.png";

/***/ }),

/***/ "./src/assets/paw.png":
/*!****************************!*\
  !*** ./src/assets/paw.png ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/paw.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=main.js.map